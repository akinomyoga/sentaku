#!/usr/bin/env bash

## Description {{{
#
# Utility to make sentaku (selection) window with shell command.
#
# Homepage: https://github.com/rcmdnk/sentaku
#
# Usage: sentaku [-HNladnh] [-f <file>] [-s <sep>] [input variables]
#
#
SENTAKU_VERSION=v0.7.2
SENTAKU_DATE="10/May/2019"
#
# }}}

## License {{{
#
#The MIT License (MIT)
#
#Copyright (c) 2014 rcmdnk
#
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# }}}

# Utilities # {{{
function sentaku/string#nth {
  local -i arg=$1
  local digit=$arg
  ((digit<0)) && ((digit=-digit))
  ((digit>=20)) && ((digit%=10))
  case $digit in
  (1) ret=${arg}st ;;
  (2) ret=${arg}nd ;;
  (3) ret=${arg}rd ;;
  (*) ret=${arg}th ;;
  esac
}

## @fn sentaku/string#cut-word <var> <max_length> [<is_last_show>]
function sentaku/string#cut-word {
  local var=$1
  local max_length=$2
  local is_last_show=${3:-0}
  local _value=${!var}
  if ((is_last_show&&${#_value}>=max_length)); then
    _value=${_value:${#_value}-max_length}
  else
    ble/util/sprintf _value "%-${max_length}.${max_length}s" "$_value"
  fi
  eval "$var=\$_value"
  return
}

function sentaku/string#replace-icase {
  if ((_ble_bash>=30100)); then
    ble/string#escape-for-bash-glob "$2"; local pat=$ret
    ret=$(shopt -s nocasematch; echo "${1//$2/"$3"}")
  else
    # Similar replace can be done by GNU sed, BSD sed doesn't support ignore case option
    ble/string#escape-for-awk-regex "$2"; local pat=$ret
    ble/string#escape-for-awk-regex "$3"; local rep=$ret
    ret=$(<<< $1 perl -pe "s|($pat)|$rep|gi")
  fi
}
# }}}

# Default variables # {{{
_SENTAKU_INPUT_FILE=${_SENTAKU_INPUT_FILE:-}
_SENTAKU_SEPARATOR=${_SENTAKU_SEPARATOR:-$IFS}
_SENTAKU_MAX=${_SENTAKU_MAX:-20}
_SENTAKU_MIN_SHOW=${_SENTAKU_MIN_SHOW:-3}
_SENTAKU_NOHEADER=${_SENTAKU_NOHEADER:-0}
_SENTAKU_NONUMBER=${_SENTAKU_NONUMBER:-0}
_SENTAKU_SHOWLAST=${_SENTAKU_SHOWLAST:-0}
_SENTAKU_CHILD=${_SENTAKU_CHILD:-0}
# 0: AND (smart case), 1: AND (case sensitive), 2: starts with (smart case), 3: starts with (case sensitive)
_SENTAKU_SEARCH_OPT=${_SENTAKU_SEARCH_OPT:-0}
_SENTAKU_PAGE_CHANGE=${_SENTAKU_PAGE_CHANGE:-1}
_SENTAKU_KEYMODE=${_SENTAKU_KEYMODE:-0}
_SENTAKU_COLOR_NUM_ONLY=${_SENTAKU_COLOR_NUM_ONLY:-0}
_SENTAKU_LINE_HIGHLIGHT=${_SENTAKU_LINE_HIGHLIGHT:-1}
_SENTAKU_DEBUG=${_SENTAKU_DEBUG:-0}
# }}}

function sentaku/help {
  if [[ -t 1 ]]; then
    echo "$_sentaku_help" | ${PAGER:-less} >/dev/tty
  else
    echo "$_sentaku_help"
  fi
}

_SENTAKU_VARIABLES=(
  _sentaku_file
  _sentaku_file_use
  _sentaku_sep
  _sentaku_sep_push
  _sentaku_items
  _sentaku_items_cmdline
  _sentaku_count
  _sentaku_max
  _sentaku_min_show
  _sentaku_header
  _sentaku_opt_noheader
  _sentaku_opt_nonumber
  _sentaku_opt_showlast
  _sentaku_opt_search
  _sentaku_opt_pagechange
  _sentaku_opt_keymode
  _sentaku_opt_color_num
  _sentaku_opt_line_highlight
  _sentaku_opt_debug
  _sentaku_show
  _sentaku_rows
  _sentaku_cols
  _sentaku_max_show
  _sentaku_stdin
  _sentaku_opt_savechange
  _sentaku_opt_align
  _sentaku_opt_delete
  _sentaku_opt_noshow
  _sentaku_trapped
  _sentaku_normal_echo

  _sentaku_invalidated

  _sentaku_ext_rows
  _sentaku_n_current
  _sentaku_n_offset
  _sentaku_g_count
  _sentaku_arg
  _sentaku_visual
  _sentaku_visual_list
  _sentaku_search
  _sentaku_search_words
  _sentaku_items_n
  _sentaku_items_{0..999}

  _sentaku_help

  _sentaku_stty_state
  _sentaku_ret
)

function sentaku/initialize {
  # Set variables
  _sentaku_file=${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE}
  _sentaku_file_use=0
  _sentaku_sep=${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR}
  # If a separator is normal IFS, use space for file write out.
  # note: $' \t\n' should not be surrounded by '"'.
  if [[ $_sentaku_sep == $' \t\n' ]];then
    _sentaku_sep_push=' '
  else
    _sentaku_sep_push=$_sentaku_sep
  fi
  _sentaku_items=()
  _sentaku_items_cmdline=
  _sentaku_count=0
  _sentaku_max=${SENTAKU_MAX:-$_SENTAKU_MAX}
  _sentaku_min_show=${SENTAKU_MIN_SHOW:-$_SENTAKU_MIN_SHOW}
  _sentaku_header=

  _sentaku_opt_search=${SENTAKU_SEARCH_OPT:-$_SENTAKU_SEARCH_OPT}
  _sentaku_opt_noheader=${SENTAKU_NONUMBER:-$_SENTAKU_NONUMBER}
  _sentaku_opt_nonumber=${SENTAKU_NONUMBER:-$_SENTAKU_NONUMBER}
  _sentaku_opt_showlast=${SENTAKU_SHOWLAST:-$_SENTAKU_SHOWLAST}
  _sentaku_opt_pagechange=${SENTAKU_PAGE_CHANGE:-$_SENTAKU_PAGE_CHANGE}
  _sentaku_opt_keymode=${SENTAKU_KEYMODE:-$_SENTAKU_KEYMODE}
  _sentaku_opt_color_num=${SENTAKU_COLOR_NUM_ONLY:-$_SENTAKU_COLOR_NUM_ONLY}
  _sentaku_opt_line_highlight=${SENTAKU_LINE_HIGHLIGHT:-$_SENTAKU_LINE_HIGHLIGHT}
  _sentaku_opt_debug=${SENTAKU_DEBUG:-$_SENTAKU_DEBUG}

  _sentaku_show=
  _sentaku_rows=0
  _sentaku_cols=0
  _sentaku_max_show=0
  _sentaku_opt_savechange=0
  _sentaku_opt_align=0
  _sentaku_opt_delete=0
  _sentaku_opt_noshow=0
  _sentaku_stdin=0
  _sentaku_trapped=0
  _sentaku_normal_echo=${_sentaku_normal_echo:-1}

  _sentaku_invalidated=1

  _sentaku_ext_rows=0
  _sentaku_n_current=-1
  _sentaku_n_offset=0
  _sentaku_g_count=0
  _sentaku_arg=-1

  ## @var _sentaku_visual
  ##   _sentaku_visual=-1 ... single selection mode
  ##   _sentaku_visual=-2 ... visual selection mode
  ##   _sentaku_visual>=0 ... visual selection mode (currently selecting)
  _sentaku_visual=-1
  _sentaku_visual_list=()

  _sentaku_search=
  _sentaku_search_words=
  _sentaku_items_n=0
  eval '_sentaku_items_'{0..999}'=();'
  _sentaku_stty_state=

  _sentaku_ret=0

  # Help
  _sentaku_help=${_sentaku_help:-"Usage: sentaku [-HNladnh] [-f <file>] [-s <sep>] [input variables]

Arguments:
  -f <file>  Set input file
  -s <sep>   Set separator (default: ${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR})
             If <sep> is \"line\", \$'\\n' is set as a separator.
  -H         Force to show a header at sentaku window.
  -N         No numbers are shown.
  -U         Use underline to show selected line, instead of highlighting.
  -l         Show last words instead of starting words for longer lines.
  -m         Save changes to <file>.
  -a         Align input list (set selected one to the first) [implies -m].
  -r <n>     Return nth value directly.
  -p         Push words to the file.
  -E         Use Emacs mode
  -V         Use Vim mode
  -c         Load functions as a child process in other sentaku process.
  -n         Don't run functions, to just source this file
  -v         Show version
  -h         Print this HELP and exit

Key operation at sentaku window
  Common for all:
    C-p/C-n  Up/Down.
    C-u/C-d  Half page down/Half page down.
    C-b/C-f  Page up/Page down.
    M-v/C-v  Page up/Page down.
    C-a/C-e  Go to the beginning/end.
    C-i/C-o  Move the item up/down.
    C-x      Quit.
    C-s      Start/Stop Visual mode (multi-selection).
    Space    Select/unselect current line for multi-selection.
             At Emacs mode or search mode in Vim mode,
             it selects when space is pushed twice.
    Esc      At search mode, first Esc takes it back to normal mode
             with selected words.
             Second Esc clear search mode.
             Visual mode is cleared by first Esc.
    Enter    Select and Quit.

  For Vim mode:
    n(any number) Set number. Multi-digit can be used (13, 320, etc...).
                  Used/reset by other key.
    k/j      Up/Down (if n is given, n-th up/n-th down).
    gg/G     Go to top/bottom. (If n is given, move to n-th candidate.)
    d        Delete current candidate. (in case you use input file.)
    s        Show detail of current candidate.
    v        Visual mode, same as C-s
    /        Search.
    q        Quit.
    Others   Nothing happens.

  For Emacs mode:
    Others   Normal keys start an incremental search.
"}

  # Lines and columns at beginning
  _sentaku_rows=$LINES
  _sentaku_cols=$COLUMNS
  [[ $_sentaku_rows ]] || _sentaku_rows=$(tput lines)
  [[ $_sentaku_cols ]] || _sentaku_cols=$(tput cols)

  # Check std input
  [[ ! -t 0 ]] && _sentaku_stdin=1

  # User initialization
  sentaku/INITIALIZE
}

function sentaku/INITIALIZE { :; }

function sentaku/list#clear {
  _sentaku_visual_list=()
}
function sentaku/list#set {
  local -i index=$1 arg=$2
  if ((arg)); then
    _sentaku_visual_list[index]=$arg
  else
    unset '_sentaku_visual_list[index]'
  fi
}
function sentaku/list#rotate {
  local a=$1 b=$2 shift=$3
  local -a selected
  selected=("${!_sentaku_visual_list[@]}")
  _sentaku_visual_list=()
  local i
  for i in "${selected[@]}"; do
    if ((a<=i&&i<b)); then
      if ((i<b-shift)); then
        ((i+=shift))
      else
        ((i-=b-shift))
      fi
    fi
    _sentaku_visual_list[i]=1
  done
}

SENTAKU_REPLY=()
SENTAKU_INDEX=()
function sentaku/execute {
  if ((_sentaku_visual!=-1));then
    SENTAKU_REPLY=()
    SENTAKU_INDEX=("${!_sentaku_visual_list[@]}")
    local i
    for i in "${SENTAKU_INDEX[@]}"; do
      ble/array#push SENTAKU_REPLY "${_sentaku_items[i]}"
    done
  else
    SENTAKU_INDEX=("$_sentaku_n_current")
    SENTAKU_REPLY=("${_sentaku_items[_sentaku_n_current]}")
  fi

  ((_sentaku_opt_align==1&&_sentaku_stdin==0)) &&
    sentaku/align-values "$_sentaku_n_current" 0

  eval -- "$SENTAKU_CALLBACK"
}

#------------------------------------------------------------------------------
# mode: sentaku/pause

function ble/widget/sentaku_pause/exit { ble-decode/keymap/pop; }
function ble-decode/keymap:sentaku_pause/define {
  local ble_bind_keymap=sentaku_pause
  ble-bind -f __default__ sentaku_pause/exit
}
function sentaku/pause {
  ble-decode/keymap/push sentaku_pause
}

#------------------------------------------------------------------------------
# mode: sentaku/yn

function ble/widget/sentaku_yn/__before_widget__ {
  clear >/dev/tty
  echo "$message [y/n]: " >/dev/tty
}
function ble/widget/sentaku_yn/yes {
  ble-decode/keymap/pop
  true
  eval "$_sentaku_yn_callback"
}
function ble/widget/sentaku_yn/no {
  ble-decode/keymap/pop
  ble/widget/sentaku/quit # ???
  false
  eval "$_sentaku_yn_callback"
}
function ble-decode/keymap:sentaku_yn/define {
  local ble_bind_keymap=sentaku_tn
  ble-bind -f __default__ nop
  ble-bind -f __before_widget__ sentaku_yn/__before_widget__
  ble-bind -f y sentaku_yn/yes
  ble-bind -f n sentaku_yn/no
}

_sentaku_yn_callback=
function sentaku/yn {
  _sentaku_yn_callback=$1; shift
  local message="$*"
  ble-decode/keymap/push sentaku_yn
  return 148
}

#------------------------------------------------------------------------------

## @fn sentaku/check-args
##   @var[out] flag_continue
function sentaku/check-args {
  # Get arguments
  flag_continue=0
  while (($#)); do
    case $1 in
    ("-f"|"-F") # Use file
      _sentaku_file=$2
      _sentaku_file_use=1
      if [[ ! $_sentaku_file ]];then
        echo "ERROR: empty input was given with -i" >/dev/tty
        return 1
      fi
      shift ;;
    ("-s") # Set separator
      _sentaku_sep=$2
      if [[ $_sentaku_sep == line ]];then
        _sentaku_sep=$'\n'
      fi
      if [[ $_sentaku_sep = $' \t\n' ]];then
        _sentaku_sep_push=' '
      else
        _sentaku_sep_push=$_sentaku_sep
      fi
      shift ;;
    ("-H") _sentaku_opt_noheader=0 ;;
    ("-N") _sentaku_opt_nonumber=1;;
    ("-U") _sentaku_opt_line_highlight=0;;
    ("-l") _sentaku_opt_showlast=1;;
    ("-a") _sentaku_opt_savechange=1 _sentaku_opt_align=1 ;;
    ("-m") _sentaku_opt_savechange=1 ;;
    ("-r")
      if [[ "$2" =~ ^[0-9]+$ ]];then
        _sentaku_n_current=$2
        shift
      else
        echo "-r option requires a number" >/dev/tty
        return 1
      fi
      ;;
    ("-p")
      shift
      sentaku/push "$@"
      return $? ;;
    ("-E") _sentaku_opt_keymode=1;;
    ("-V") _sentaku_opt_keymode=0;;
    ("-c") _SENTAKU_CHILD=1;;
    ("-v") echo "$(basename "$0") $SENTAKU_VERSION $SENTAKU_DATE" >/dev/tty; return 0;;
    ("-h")
      sentaku/help
      return 0 ;;
    (-*)
      echo "$(basename "$0") $1: unknown argument
Check \"$(basename "$0" ) -h\" for further information" >/dev/tty
      return 1
      ;;
    (*)
      break ;;
    esac
    shift
  done
  _sentaku_items_cmdline="$*"
  flag_continue=1
  return 0
}

function sentaku/push {
  # Set input
  local input="$*"
  shift $#
  if ((_sentaku_stdin==1)); then
    input=$(cat -)
  fi

  # Ignore blank
  if [[ ! $input ]]; then
    return 1
  fi

  # Renew values
  sentaku/get-values 0 0
  local -a new_items; ble/string#split new_items "$_sentaku_sep_push" "$input"
  _sentaku_items=("${new_items[@]}" "${_sentaku_items[@]}")
  _sentaku_count=${#_sentaku_items[@]}
  sentaku/align-values 0 0

  sentaku/echoln "$input is stored in $_sentaku_file"
}

## @fn sentaku/get-values [<is_stdin> [<is_check>]]
function sentaku/get-values {
  sentaku/get-values.impl "$1" "$2"
  if ((_sentaku_count==0)); then
    return 1
  else
    sentaku/setview
  fi
}

## @fn sentaku/get-values.impl [<is_stdin> [<is_check>]]
function sentaku/get-values.impl {
  local stdin=${1:-$_sentaku_stdin}
  local check=${2:-1}

  # Get values
  local input=
  if ((stdin==0||_sentaku_file_use==1)); then
    if ((_sentaku_file_use==0)) && [[ ! $_sentaku_file ]]; then
      input=$_sentaku_items_cmdline
    else
      touch "$_sentaku_file"
      input=$(< "$_sentaku_file")
    fi
  else
    input=$(cat -)
  fi
  ble/string#split _sentaku_items "$_sentaku_sep" "$input"
  _sentaku_count=${#_sentaku_items[@]}

  if ((check==1&&_sentaku_count==0)); then
    if ((stdin==0||_sentaku_file_use==1)); then
      sentaku/echoln "No value in $_sentaku_file\\n"
    else
      sentaku/echoln "No value in stdin\\n"
    fi
    _sentaku_ret=1
    return
  elif ((_sentaku_count>0)); then
    sentaku/list#clear
  fi
  _sentaku_ret=0
}
function sentaku/set-items {
  _sentaku_items=("$@")
  _sentaku_count=$#
  sentaku/list#clear
}

## @fn sentaku/align-values [<n> [<is_get>]]
function sentaku/align-values {
  local n=${1:-$_sentaku_n_current}
  local is_get=${2:-1}
  if [[ ! $n =~ ^[0-9]+$ || n -ge _sentaku_count ]];then
    sentaku/echoln "$n is not valid for sentaku/align-values"
    return 1
  fi
  local v="${_sentaku_items[$n]}"
  printf "%s$_sentaku_sep_push" "$v" > "$_sentaku_file"
  local i
  for ((i=0;i<_sentaku_count;i++)); do
    ((i>=_sentaku_max)) && break
    if [[ ${_sentaku_items[i]} != "$v" ]]; then
      printf "%s$_sentaku_sep_push" "${_sentaku_items[$i]}" >> "$_sentaku_file"
    fi
  done
  if ((is_get==1)); then
    sentaku/get-values
  fi
}

## sentaku/show [<is_selected>] [<n_show>]
function sentaku/show {
  local is_selected=${1:-0}
  local n_show=${2:-$_sentaku_cols}
  sentaku/string#cut-word _sentaku_show "$n_show" "$_sentaku_opt_showlast"

  # Color search words
  if [[ $_sentaku_search_words ]];then
    local ignore_case=0
    local search_words=$_sentaku_search_words
    if ((_sentaku_opt_search==0||_sentaku_opt_search==2)); then
      local ret; ble/string#tolower "$_sentaku_search_words"; local words_lower=$ret
      if [[ $words_lower == "$_sentaku_search_words" ]]; then
        local ignore_case=1
        search_words=$words_lower
      fi
    fi

    local negative=""
    if ((is_selected==1)); then
      negative=";7"
    fi

    if ((_sentaku_opt_search<=1)); then
      local -a words
      ble/string#split words "$IFS" "$search_words"
      local w
      for w in "${words[@]}";do
        if ((ignore_case==1)); then
          local ret
          sentaku/string#replace-icase "$_sentaku_show" "$w" "\\e[31${negative}m$w\\e[0${negative}m"
          _sentaku_show=$ret
        else
          local ret; ble/string#escape-for-bash-glob "$w"; local pat=$ret
          _sentaku_show="${_sentaku_show//$pat/\\e[31${negative}m$w\\e[${negative}m}"
        fi
      done
    else
      if ((ignore_case==1)); then
        _sentaku_show=$(echo "$_sentaku_show"|perl -pe "s|(^$search_words)|\\e[31${negative}m\\1\\e[0${negative}m|gi")
      else
        _sentaku_show="\\e[31${negative}m$search_words\\e[${negative}m${_sentaku_show#$search_words}"
      fi
    fi
  fi
}

## usage: sentaku/printline is_selected n_line n_input
function sentaku/printline {
  local is_selected=$1
  local n_line=$2
  local n_input=$3

  local color=""
  if [[ ${_sentaku_visual_list[n_input]} ]];then
    color="[36m"
  fi
  if ((is_selected==1)); then
    if ((_sentaku_opt_line_highlight==1));then
      color="${color}[7m"
    else
      color="${color}[4m"
    fi
  fi

  # Change line breaks to \n (to be shown), remove the last line break, replace tab to space
  _sentaku_show=${_sentaku_items[$n_input]//$'\n'/\\\\n}
  _sentaku_show=${_sentaku_show%\\\\n}
  _sentaku_show=${_sentaku_show//$'\t'/ }

  tput cup "$n_line" 0 >/dev/tty
  local n_show=$_sentaku_cols
  local num=""
  if ((_sentaku_opt_nonumber==0)); then
    local nmax=$((_sentaku_count-1))
    local num_width=${#nmax}
    if ((num_width+2<n_show)); then
      ((n_show-=num_width+2))
      ble/util/sprintf num "%${num_width}s: " "$n_input"
    fi
  fi
  sentaku/show "$is_selected" "$n_show"
  if ((_sentaku_opt_color_num==1)); then
    printf '%s' "${color}${num}[m${_sentaku_show}" >/dev/tty
  else
    printf '%s' "${color}${num}${_sentaku_show}[m" >/dev/tty
  fi
  tput cup "$n_line" 0 >/dev/tty
}

## print current line
function sentaku/print_current_line {
  sentaku/printline 1 $((_sentaku_n_current-_sentaku_n_offset+_sentaku_ext_rows)) $_sentaku_n_current
}

## usage: sentaku/printall [not force]
function sentaku/printall {
  # if any argument is given, check if echoed or not.
  (($#&&_sentaku_invalidated==0)) && return

  local lines=$_sentaku_rows
  local cols=$_sentaku_cols
  _sentaku_rows=$(tput lines)
  _sentaku_cols=$(tput cols)

  sentaku/setview

  if ((lines!=_sentaku_rows||cols!=_sentaku_cols)); then
    _sentaku_n_current=0
    _sentaku_n_offset=0
  fi

  clear >/dev/tty

  # Header
  sentaku/util/print "${_sentaku_header}"

  local i
  for ((i=0;i<_sentaku_max_show;i++)); do
    ((i+_sentaku_n_offset>=_sentaku_count)) && break
    if ((i+_sentaku_n_offset==_sentaku_n_current)); then
      sentaku/print_current_line
    else
      sentaku/printline 0 $((i+_sentaku_ext_rows)) $((i+_sentaku_n_offset))
    fi
  done
  _sentaku_invalidated=0
}

function sentaku/util/print {
  printf "%b" "$*" >/dev/tty
}

function sentaku/echo {
  ((_sentaku_opt_noshow==1)) && return
  if ((_sentaku_normal_echo==1)); then
    sentaku/util/print "$*"
  else
    clear >/dev/tty
    sentaku/util/print "$*"
    _sentaku_invalidated=1
    ble/util/msleep 500
    sentaku/pause
  fi
}

function sentaku/echoln {
  sentaku/echo "$*\\n"
}

function sentaku/echo-debug {
  if [[ ! $_sentaku_opt_debug ]]; then
    # Temporarily use default value for debug_echo before initialization.
    _sentaku_opt_debug=$_SENTAKU_DEBUG
  fi
  if ((_sentaku_opt_debug>0)); then
    sentaku/echo "$*"
  fi
}

function sentaku/echoln-debug {
  sentaku/echo-debug "$*\\n"
}

function sentaku/echo-printall {
  sentaku/echo "$*"
  sentaku/printall
}

function sentaku/set-header {
  _sentaku_header="\\e[43;30m$_sentaku_count values in total\\e[0m "
  ((_sentaku_opt_noheader==1)) && return
  if ((_sentaku_opt_delete)); then
    local delete_key="d(delete), "
  else
    local delete_key=""
  fi
  if ((_sentaku_opt_keymode==0)); then
    if ((_sentaku_cols>=68));then
      _sentaku_header="$_sentaku_header
  [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n)
  ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up)
  ${delete_key}/(search), Enter/Space(select), q(quit)"
    elif ((_sentaku_cols>=41));then
      _sentaku_header="$_sentaku_header
  vimike updown, e.g)j:down, k:up, gg/G
  ${delete_key}Enter/Space(select), q(quit)"
    fi
  else
    if ((_sentaku_cols>=51)); then
      _sentaku_header="$_sentaku_header
  C-n(down), C-j(up), C-v(Page down), M-v(Page up)
  Enter(select), C-x(quit)
  Other normal keys start an incremental search"
    fi
  fi
}

function sentaku/setview {
  if ((_sentaku_rows<=_sentaku_min_show)); then
    _sentaku_header=
    _sentaku_ext_rows=0
  elif ((_sentaku_rows==_sentaku_min_show+1)); then
    _sentaku_header=${_sentaku_search}
    _sentaku_ext_rows=1
  else
    sentaku/set-header
    _sentaku_header="$_sentaku_header\\n$_sentaku_search"
    if (($(printf "%b\n" "$_sentaku_header"|grep -c ^)>_sentaku_rows-_sentaku_min_show)); then
      _sentaku_header="\e[43;30m$_sentaku_count values in total\e[0m\n${_sentaku_search}"
    fi
    _sentaku_ext_rows=$(printf "%b\n" "$_sentaku_header"|grep -c ^)
  fi

  _sentaku_max_show=$_sentaku_count
  if ((_sentaku_count>_sentaku_rows-_sentaku_ext_rows)); then
    _sentaku_max_show=$((_sentaku_rows-_sentaku_ext_rows))
  fi
}

function sentaku/reset {
  _sentaku_n_current=0
  _sentaku_n_offset=0
  _sentaku_g_count=0
  _sentaku_arg=-1
  _sentaku_visual=-1
  sentaku/list#clear
  tput cup "$_sentaku_ext_rows" 0 >/dev/tty
  sentaku/printall
}

function ble/widget/sentaku/quit {
  (($#)) && _sentaku_ret=$1
  _sentaku_n_current=-1
  ble-decode/keymap/pop
}
function ble/widget/sentaku/accept {
  ble-decode/keymap/pop
  sentaku/execute
}

#------------------------------------------------------------------------------
# moves


## @fn sentaku/goto.impl new_pos opts
##
##   @param[in] new_pos
##     new cursor position
##
##   @param[in] opts
##     comma separated list of the following values:
##
##     "carry" carry the current item with cursor
##
function sentaku/goto.impl {
  local new_pos=$1 opts=$2
  _sentaku_g_count=0
  _sentaku_arg=-1

  local old_pos=$_sentaku_n_current
  if ((new_pos<0)); then
    ((new_pos=0))
  elif ((new_pos>=_sentaku_count)); then
    ((new_pos=_sentaku_count-1))
  fi
  ((new_pos==old_pos)) && return

  local old_cursor_r=$((_sentaku_n_current-_sentaku_n_offset+_sentaku_ext_rows))
  local new_ofs=$_sentaku_n_offset
  local flag_all=
  if ((new_pos>=new_ofs+_sentaku_max_show)); then
    if ((_sentaku_opt_pagechange==0)); then
      ((new_ofs=new_pos+1-_sentaku_max_show))
    else
      ((new_ofs=new_pos-new_pos%_sentaku_max_show))
    fi
    flag_all=1
  elif ((new_pos<new_ofs)); then
    if ((_sentaku_opt_pagechange==0)); then
      ((new_ofs=new_pos))
    else
      ((new_ofs=new_pos-new_pos%_sentaku_max_show))
    fi
    flag_all=1
  fi
  _sentaku_n_current=$new_pos
  _sentaku_n_offset=$new_ofs

  [[ $flag_all ]] && _sentaku_invalidated=1

  if [[ :$opts: == *:carry:* ]]; then
    if ((new_pos>old_pos)); then
      local a=$old_pos b=$((new_pos+1)) shift=$((new_pos-old_pos))
    else
      local a=$new_pos b=$((old_pos+1)) shift=1
    fi
    _sentaku_items=("${_sentaku_items[@]::a}"
                    "${_sentaku_items[@]:b-shift:shift}"
                    "${_sentaku_items[@]:a:b-a-shift}"
                    "${_sentaku_items[@]:b}")

    ((_sentaku_visual>=0)) && _sentaku_visual=-2
    if ((_sentaku_visual!=-1)); then
      sentaku/list#rotate "$a" "$b" "$shift"
    fi

    ((_sentaku_opt_savechange&&_sentaku_stdin==0)) &&
      sentaku/align-values 0 0

    if [[ ! $flag_all ]]; then
      local i r=$((a-_sentaku_n_offset+_sentaku_ext_rows))
      for ((i=a;i<b;i++,r++)); do
        if ((i==new_pos)); then
          sentaku/print_current_line
        else
          sentaku/printline 0 "$r" "$i"
        fi
      done
    fi
  elif ((_sentaku_visual>=0)); then
    local tmp_r=$old_cursor_r
    local tmp_n=$old_pos
    if ((new_pos>old_pos)); then
      while ((tmp_n<new_pos)); do
        sentaku/list#set "$tmp_n" $((_sentaku_visual<=tmp_n))
        [[ $flag_all ]] || sentaku/printline 0 $tmp_r $tmp_n
        ((tmp_r++,tmp_n++))
      done
    elif ((new_pos<old_pos)); then
      while ((tmp_n>new_pos)); do
        sentaku/list#set "$tmp_n" $((_sentaku_visual>=tmp_n))
        [[ $flag_all ]] || sentaku/printline 0 $tmp_r $tmp_n
        ((tmp_r--,tmp_n--))
      done
    fi
    _sentaku_visual_list[_sentaku_n_current]=1
    [[ $flag_all ]] || sentaku/print_current_line
  else
    if [[ ! $flag_all ]]; then
      sentaku/printline 0 $old_cursor_r $old_pos
      sentaku/print_current_line
    fi
  fi
}

function ble/widget/sentaku/append-arg {
  local n=${1:-0}
  ((_sentaku_arg=_sentaku_arg>0?_sentaku_arg*10+n:n))
}

## The line goes Down. (Increase the line number)
function ble/widget/sentaku/forward-item {
  ((_sentaku_arg<=0)) && _sentaku_arg=1
  sentaku/goto.impl $((_sentaku_n_current+_sentaku_arg))
}
## The line goes up. (Decrease the line Number!)
function ble/widget/sentaku/backward-item {
  ((_sentaku_arg<=0)) && _sentaku_arg=1
  sentaku/goto.impl $((_sentaku_n_current-_sentaku_arg))
}
function ble/widget/sentaku/page-up {
  sentaku/goto.impl $((_sentaku_n_current-_sentaku_max_show))
}
function ble/widget/sentaku/page-down {
  sentaku/goto.impl $((_sentaku_n_current+_sentaku_max_show))
}
function ble/widget/sentaku/half-page-down {
  sentaku/goto.impl $((_sentaku_n_current+_sentaku_max_show/2))
}
function ble/widget/sentaku/half-page-up {
  sentaku/goto.impl $((_sentaku_n_current-_sentaku_max_show/2))
}
function sentaku/goto {
  sentaku/goto.impl "$_sentaku_arg"
}
function ble/widget/sentaku/goto-line-or-top {
  if ((_sentaku_g_count==0)); then
    _sentaku_g_count=1
    return
  fi
  ((_sentaku_arg<0)) && _sentaku_arg=0
  sentaku/goto
}
function ble/widget/sentaku/goto-line-or-end {
  ((_sentaku_arg<0)) && _sentaku_arg=$_sentaku_count
  sentaku/goto
}
# function for <C-a>-<C-Z>, <C-Space>
function ble/widget/sentaku/goto-top {
  _sentaku_arg=0
  sentaku/goto
  #local i
  #for ((i=0;i<_sentaku_count;i++)); do
  #  _sentaku_visual=-2
  #  _sentaku_visual_list[i]=1
  #done
  #_sentaku_invalidated=1
}
function ble/widget/sentaku/goto-end {
  _sentaku_arg=$_sentaku_count
  sentaku/goto
}

#------------------------------------------------------------------------------
# edit items

function sentaku/delete {
  : >| "$_sentaku_file"
  local i
  local old_current_n=$_sentaku_n_current
  for ((i=0;i<_sentaku_count;i++)); do
    if ((_sentaku_visual!=-1&&_sentaku_visual_list[i]||_sentaku_visual==-1&&i==old_current_n)); then
      ((i<old_current_n&&_sentaku_n_current--))
      continue
    fi
    printf "%s$_sentaku_sep_push" "${_sentaku_items[$i]}" >> "$_sentaku_file"
  done
  sentaku/get-values
}

function sentaku/remove {
  local old_current_n=$_sentaku_n_current
  if ((_sentaku_visual!=-1)); then
    local i
    for i in "${!_sentaku_visual_list[@]}"; do
      unset '_sentaku_items[i]'
      ((i<old_current_n&&_sentaku_n_current--))
    done
  else
    unset '_sentaku_items[_sentaku_n_current]'
  fi
  _sentaku_items=("${_sentaku_items[@]}")
  _sentaku_count=${#_sentaku_items[@]}
  sentaku/list#clear
}

function ble/widget/sentaku/raise-item {
  ((_sentaku_arg<=0)) && _sentaku_arg=1
  sentaku/goto.impl $((_sentaku_n_current-_sentaku_arg)) carry
}
function ble/widget/sentaku/lower-item {
  ((_sentaku_arg<=0)) && _sentaku_arg=1
  sentaku/goto.impl $((_sentaku_n_current+_sentaku_arg)) carry
}
function ble/widget/sentaku/delete-item {
  ((_sentaku_opt_delete)) || return 1

  local old_current_n=$_sentaku_n_current
  if ((_sentaku_opt_savechange&&_sentaku_stdin==0)); then
    sentaku/delete
  else
    sentaku/remove
  fi
  if ((_sentaku_count==0)); then
    sentaku/echoln "There are no remained entries"
    _sentaku_ret=1
  fi
  if ((_sentaku_ret));then
    ble/widget/sentaku/quit $_sentaku_ret
    return
  fi
  if ((_sentaku_n_current>=_sentaku_count)); then
    ((_sentaku_n_current=_sentaku_count-1))
  fi
  if ((_sentaku_n_current<_sentaku_n_offset)); then
    _sentaku_n_offset=$_sentaku_n_current
  fi
  local n_move
  if ((_sentaku_count<_sentaku_rows-_sentaku_ext_rows+_sentaku_n_offset)); then
    local n_move=$((_sentaku_rows-_sentaku_ext_rows+_sentaku_n_offset-_sentaku_count))
    if ((n_move>_sentaku_n_offset)); then
      n_move=$_sentaku_n_offset
    fi
    ((_sentaku_n_offset=_sentaku_n_offset-n_move))
  fi
  _sentaku_visual=-1
  sentaku/list#clear
  _sentaku_invalidated=1
}

#------------------------------------------------------------------------------
# mode: sentaku/search

function sentaku/search/update {
  local opts=$1
  _sentaku_search="\e[41;30mSearch:\e[0m \e[31m$_sentaku_search_words\e[0m"

  if [[ ! $_sentaku_search_words ]];then
    _sentaku_items=("${_sentaku_items_0[@]}")
    _sentaku_count=${#_sentaku_items[@]}
  elif [[ :$opts: == *:delete:* ]];then
    :
  else
    local -a inputs
    inputs=()
    local i j=0
    for ((i=0;i<_sentaku_count;i++)); do
      if sentaku/search/check "${_sentaku_items[i]}";then
        inputs[j]=${_sentaku_items[$i]}
        ((j++))
      fi
    done
    _sentaku_items=("${inputs[@]}")
    _sentaku_count=${#_sentaku_items[@]}
    ((_sentaku_items_n++))
    eval "_sentaku_items_${_sentaku_items_n}=(\"\${_sentaku_items[@]}\")"
  fi

  sentaku/reset
}
function sentaku/search/check {
  local input="$1"
  local search_words=$_sentaku_search_words

  if ((_sentaku_opt_search==0||_sentaku_opt_search==2)); then
    local ret
    ble/string#tolower "$input"; local input_lower=$ret
    ble/string#tolower "$_sentaku_search_words"; local words_lower=$ret
    if [[ $words_lower == "$_sentaku_search_words" ]]; then
      input=$input_lower
      search_words=$words_lower
    fi
  fi
  if ((_sentaku_opt_search<=1)); then
    local -a words
    ble/string#split words "$IFS" "$search_words"
    local w
    for w in "${words[@]}";do
      if ((_sentaku_opt_search<=1)); then
        if [[ $input != *"$w"* ]];then
          return 1
        fi
      fi
    done
  else
    if [[ $input != "$search_words"* ]];then
      return 1
    fi
  fi
  return 0
}

function ble/widget/sentaku_search/backspace {
  if [[ ! $_sentaku_search_words ]]; then
    _sentaku_search=
    _sentaku_search_words=
    sentaku/reset
    ble-decode/keymap/pop
    return
  fi
  sentaku/string#cut-word _sentaku_search_words $((${#_sentaku_search_words}-1))
  ((_sentaku_items_n--))
  eval "_sentaku_items=(\"\${_sentaku_items_$((_sentaku_items_n))[@]}\")"
  _sentaku_count=${#_sentaku_items[@]}
  sentaku/search/update delete
}
function ble/widget/sentaku_search/quit {
  ble-decode/keymap/pop
  ble/widget/sentaku/quit
}
function ble/widget/sentaku_search/accept {
  ble-decode/keymap/pop

  # Align values
  if [[ $_sentaku_search ]]; then
    if ((_sentaku_visual!=-1)); then
      local -a selected
      selected=()
      local is_first=1
      local i
      local j=0
      for i in "${!_sentaku_visual_list[@]}"; do
        selected[j++]=${_sentaku_items[i]}
      done
    else
      local val=${_sentaku_items[_sentaku_n_current]}
    fi
    _sentaku_items=("${_sentaku_items_0[@]}")
    _sentaku_count=${#_sentaku_items[@]}
    _sentaku_n_current=0
    if ((_sentaku_visual!=-1)); then
      sentaku/list#clear
      local i
      local j
      for ((i=0;i<_sentaku_count;i++)); do
        for ((j=0;j<${#selected[@]};j++)); do
          if [[ ${selected[j]} == "${_sentaku_items[i]}" ]]; then
            _sentaku_n_current=$i
            _sentaku_visual_list[i]=1
          fi
        done
      done
    else
      local i
      for ((i=0;i<_sentaku_count;i++)); do
        if [[ $val = "${_sentaku_items[i]}" ]]; then
          _sentaku_n_current=$i
          break
        fi
      done
    fi
    _sentaku_search=
  fi

  ble/widget/sentaku/accept
}
function ble/widget/sentaku_search/self-insert {
  local ret; ble/util/c2s "${KEYS[0]}"
  _sentaku_search_words=$_sentaku_search_words$ret
  sentaku/search/update
}
function ble/widget/sentaku_search/clear {
  _sentaku_search_words=""
  _sentaku_items_n=0
  sentaku/search/update
}
function ble/widget/sentaku_search/cancel {
  if ((_sentaku_count==0||_sentaku_opt_keymode==1)); then
    _sentaku_items=("${_sentaku_items_0[@]}")
    _sentaku_count=${#_sentaku_items[@]}
    _sentaku_search=
    _sentaku_search_words=
    sentaku/reset
  fi
  ble-decode/keymap/pop
}

function ble-decode/keymap:sentaku_search/define {
  local ble_bind_keymap=sentaku_search

  ble-bind -f __default__ nop
  ble-bind -f __defchar__ sentaku_search/self-insert

  ble-decode/keymap:sentaku/define-movement

  ble-bind -f 'C-x' sentaku_search/quit

  ble-bind -f 'C-h' sentaku_search/backspace
  ble-bind -f 'BS'  sentaku_search/backspace
  ble-bind -f 'C-?' sentaku_search/backspace
  ble-bind -f 'DEL' sentaku_search/backspace

  ble-bind -f 'C-j' sentaku_search/accept
  ble-bind -f 'C-m' sentaku_search/accept
  ble-bind -f 'RET' sentaku_search/accept

  ble-bind -f 'C-u' sentaku_search/clear
  ble-bind -f 'ESC' sentaku_search/cancel
}

function ble/widget/sentaku/search {
  if ((_sentaku_ext_rows==0)); then
    sentaku/echo "Too few lines for search mode."
    return
  fi
  local first_char=$1
  if [[ ! $_sentaku_search ]]; then
    _sentaku_items_0=("${_sentaku_items[@]}")
    _sentaku_items_n=0
    _sentaku_search="\e[41;30mSearch:\e[0m"
  fi
  
  if [[ ! $first_char ]]; then
    sentaku/printall
  fi
  _sentaku_search_words="$_sentaku_search_words$first_char"
  sentaku/search/update
  ble-decode/keymap/push sentaku_search
}

#------------------------------------------------------------------------------

function ble/widget/sentaku/switch-visual {
  if ((_sentaku_visual>=0)); then
    _sentaku_visual=-2
  else
    _sentaku_visual_list[_sentaku_n_current]=1
    _sentaku_visual=$_sentaku_n_current
    sentaku/print_current_line
  fi
}
function ble/widget/sentaku/toggle {
  # Space to start visual
  sentaku/list#set "$_sentaku_n_current" $((!_sentaku_visual_list[_sentaku_n_current]))
  _sentaku_visual=-2
  sentaku/print_current_line
}

function ble/widget/sentaku/show {
  local ret; sentaku/string#nth "$_sentaku_n_current"; local nth=$ret
  sentaku/echo "$nth value:

${_sentaku_items[$_sentaku_n_current]}\n"
}

function ble/widget/sentaku/redraw {
  _sentaku_invalidated=1
}

function ble/widget/sentaku/cancel {
  if ((_sentaku_visual!=-1)); then
    _sentaku_visual=-1
    sentaku/list#clear
    _sentaku_invalidated=1
  fi
  if [[ $_sentaku_search ]];then
    _sentaku_items=("${_sentaku_items_0[@]}")
    _sentaku_count=${#_sentaku_items[@]}
    _sentaku_search=
    _sentaku_search_words=""
    sentaku/reset
  fi
}

function ble-decode/keymap:sentaku/define-movement {
  ble-bind -f 'C-a' sentaku/goto-top
  ble-bind -f 'C-b' sentaku/page-up
  ble-bind -f 'C-d' sentaku/half-page-down
  ble-bind -f 'C-e' sentaku/goto-end
  ble-bind -f 'C-f' sentaku/page-down
  ble-bind -f 'C-n' sentaku/forward-item
  ble-bind -f 'C-p' sentaku/backward-item
  ble-bind -f 'C-i' sentaku/raise-item
  ble-bind -f 'C-o' sentaku/lower-item
  ble-bind -f 'C-r' sentaku/redraw
  ble-bind -f 'C-s' sentaku/switch-visual
  ble-bind -f 'C-u' sentaku/half-page-up
  ble-bind -f 'M-v' sentaku/page-up
  ble-bind -f 'C-v' sentaku/page-down
  ble-bind -f prior sentaku/page-up
  ble-bind -f next sentaku/page-down
  ble-bind -f up sentaku/backward-item
  ble-bind -f down sentaku/forward-item
}

function ble-decode/keymap:sentaku_vim/define {
  local ble_bind_keymap=sentaku_vim

  ble-decode/keymap:sentaku/define-movement

  ble-bind -f __default__ nop

  ble-bind -f 0 'sentaku/append-arg 0'
  ble-bind -f 1 'sentaku/append-arg 1'
  ble-bind -f 2 'sentaku/append-arg 2'
  ble-bind -f 3 'sentaku/append-arg 3'
  ble-bind -f 4 'sentaku/append-arg 4'
  ble-bind -f 5 'sentaku/append-arg 5'
  ble-bind -f 6 'sentaku/append-arg 6'
  ble-bind -f 7 'sentaku/append-arg 7'
  ble-bind -f 8 'sentaku/append-arg 8'
  ble-bind -f 9 'sentaku/append-arg 9'
  ble-bind -f d 'sentaku/delete-item' 
  ble-bind -f g 'sentaku/goto-line-or-top'
  ble-bind -f G 'sentaku/goto-line-or-end'
  ble-bind -f j 'sentaku/forward-item'
  ble-bind -f k 'sentaku/backward-item'
  ble-bind -f q 'sentaku/quit'
  ble-bind -f s 'sentaku/show'
  ble-bind -f v 'sentaku/switch-visual'
  ble-bind -f / 'sentaku/search'
  ble-bind -f , 'sentaku/raise-item'
  ble-bind -f . 'sentaku/lower-item'

  ble-bind -f 'C-x' sentaku/quit

  ble-bind -f SP  sentaku/toggle
  ble-bind -f C-j sentaku/accept
  ble-bind -f C-m sentaku/accept
  ble-bind -f RET sentaku/accept

  ble-bind -f delete sentaku/delete-item

  ble-bind -f ESC sentaku/cancel
}

function ble/widget/sentaku/self-insert {
  local ret; ble/util/c2s "${KEYS[0]}"
  ble/widget/sentaku/search "$ret"
}
function ble-decode/keymap:sentaku_emacs/define {
  local ble_bind_keymap=sentaku_emacs

  ble-decode/keymap:sentaku/define-movement

  ble-bind -f __default__ nop
  ble-bind -f __defchar__ sentaku/self-insert

  ble-bind -f 'C-x' sentaku/quit

  ble-bind -f SP  sentaku/toggle
  ble-bind -f C-j sentaku/accept
  ble-bind -f C-m sentaku/accept
  ble-bind -f RET sentaku/accept

  ble-bind -f delete sentaku/delete-item

  ble-bind -f ESC sentaku/cancel
}

#------------------------------------------------------------------------------

_ble_lib_app_altscreen=
function ble/lib:app/altscreen {
  [[ $_ble_lib_app_altscreen ]] && return
  _ble_lib_app_altscreen=1
  tput smcup || tput ti
} 2>/dev/null
function ble/lib:app/altscreen.reset {
 [[ $_ble_lib_app_altscreen ]] || return 0
 _ble_lib_app_altscreen=
 clear
 tput rmcup || tput te
} 2>/dev/null

_ble_lib_app_term_opts=
_ble_lib_app_term_state=
_ble_lib_app_loop_break=
_ble_lib_app_prologue=
_ble_lib_app_epilogue=
function ble/lib:app/setup-term {
  local opts=$1
  _ble_lib_app_term_opts=$opts
  _ble_lib_app_term_state=$_ble_term_state
  [[ $_ble_lib_app_term_state == external ]] && ble/term/enter

  [[ :$opts: == *:altscreen:* ]] && ble/lib:app/altscreen
  ble/util/buffer.flush
}
function ble/lib:app/reset-term {
  local opts=$_ble_lib_app_term_opts
  [[ $_ble_lib_app_term_state == external ]] && ble/term/leave

  ble/lib:app/altscreen.reset
  ble/util/buffer.flush
}
function ble/lib:app/loop {
  local -a _ble_decode_keymap_stack=()
  local _ble_decode_keymap=_

  local keymap
  for keymap in $1; do
    ble-decode/keymap/push "$keymap" || return 1
  done

  local _ble_lib_app_loop_break=
  while :; do
    eval -- "$_ble_lib_app_prologue"
    local char ret
    IFS= builtin read -r -d '' -n 1 char; local ext=$?
    ble/util/s2c "$char"
    ble-decode-char "$ret"
    eval -- "$_ble_lib_app_epilogue"

    [[ $_ble_lib_app_loop_break || $_ble_decode_keymap == _ ]] && break
  done
}
function ble/lib:app/loop#break {
  _ble_lib_app_loop_break=1
}

#------------------------------------------------------------------------------

SENTAKU_CALLBACK=
function ble/widget/sentaku {
  sentaku/initialize
  sentaku/set-items "$@"
  sentaku/reset
  local keymap=sentaku_vim
  ((_sentaku_opt_keymode==1)) && keymap=sentaku_emacs
  ble-decode/keymap/push "$keymap"
}

function sentaku/main.EPILOGUE {
  case $_ble_decode_keymap in
  (sentaku_vim|sentaku_emacs)
    sentaku/printall 1 ;;
  esac
}
function sentaku/main.core {
  local flag_continue
  sentaku/check-args "$@"; _sentaku_ret=$?
  ((_sentaku_ret)) && return
  ((flag_continue)) || return

  sentaku/get-values; _sentaku_ret=$?
  ((_sentaku_ret)) && return
  if ((_sentaku_n_current>=0)); then
    sentaku/execute
    return
  fi

  {
    ble/lib:app/setup-term
    trap -- 'ble/lib:app/reset-term > /dev/tty' HUP INT QUIT ABRT SEGV TERM
    _sentaku_normal_echo=0

    ble/lib:app/altscreen
    ble/term/cursor-state/hide

    # Initialize values
    sentaku/reset
    sentaku/printall 1
    local keymap=sentaku_vim
    ((_sentaku_opt_keymode==1)) && keymap=sentaku_emacs

    local _ble_lib_app_epilogue=sentaku/main.EPILOGUE
    ble/lib:app/loop "$keymap"

    ble-decode/keymap/pop

    _sentaku_normal_echo=1
    ble/lib:app/reset-term
  } 5<&0 6>&1 7>&2 </dev/tty >/dev/tty
}
function sentaku/main {
  local "${_SENTAKU_VARIABLES[@]}"
  sentaku/initialize
  local sep=$_sentaku_sep
  sentaku/main.core "$@"
  ((_sentaku_ret)) && return "$_sentaku_ret"

  # Output to stdout
  local is_first=1
  local item s=
  for item in "${SENTAKU_REPLY[@]}"; do
    printf '%s' "$s$item"
    s=$sep
  done
  return 0
}

# Execution part
if [[ $1 != -n ]]; then
  (sentaku/main "$@")
else
  function sentaku () (sentaku/main "$@")
fi
