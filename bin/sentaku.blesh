#!/usr/bin/env bash

## Description {{{
#
# Utility to make sentaku (selection) window with shell command.
#
# Homepage: https://github.com/rcmdnk/sentaku
#
# Usage: sentaku [-HNladnh] [-f <file>] [-s <sep>] [input variables]
#
#
SENTAKU_VERSION=v0.7.2
SENTAKU_DATE="10/May/2019"
#
# }}}

## License {{{
#
#The MIT License (MIT)
#
#Copyright (c) 2014 rcmdnk
#
#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# }}}

# Default variables # {{{
_SENTAKU_INPUT_FILE=${_SENTAKU_INPUT_FILE:-}
_SENTAKU_SEPARATOR=${_SENTAKU_SEPARATOR:-$IFS}
_SENTAKU_MAX=${_SENTAKU_MAX:-20}
_SENTAKU_MIN_SHOW=${_SENTAKU_MIN_SHOW:-3}
_SENTAKU_NOHEADER=${_SENTAKU_NOHEADER:-0}
_SENTAKU_NONUMBER=${_SENTAKU_NONUMBER:-0}
_SENTAKU_SHOWLAST=${_SENTAKU_SHOWLAST:-0}
_SENTAKU_CHILD=${_SENTAKU_CHILD:-0}
# 0: AND (smart case), 1: AND (case sensitive), 2: starts with (smart case), 3: starts with (case sensitive)
_SENTAKU_SEARCH_OPT=${_SENTAKU_SEARCH_OPT:-0}
_SENTAKU_PAGE_CHANGE=${_SENTAKU_PAGE_CHANGE:-1}
_SENTAKU_KEYMODE=${_SENTAKU_KEYMODE:-0}
_SENTAKU_COLOR_NUM_ONLY=${_SENTAKU_COLOR_NUM_ONLY:-0}
_SENTAKU_LINE_HIGHLIGHT=${_SENTAKU_LINE_HIGHLIGHT:-1}
_SENTAKU_DEBUG=${_SENTAKU_DEBUG:-0}
# }}}

function sentaku/help {
  if [[ -t 1 ]]; then
    echo "$_s_help" | ${PAGER:-less} >/dev/tty
  else
    echo "$_s_help"
  fi
}

function sentaku/initialize { # {{{
  # Set variables
  _s_file=${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE}
  _s_use_file=0
  _s_s=${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR}
  # If a separator is normal IFS, use space for file write out.
  # note: $' \t\n' should not be surrounded by '"'.
  if [[ $_s_s == $' \t\n' ]];then
    _s_s_push=' '
  else
    _s_s_push=$_s_s
  fi
  _s_inputs=()
  _s_cmd_line_inputs=
  _s_n=0
  _s_max=${SENTAKU_MAX:-$_SENTAKU_MAX}
  _s_min_show=${SENTAKU_MIN_SHOW:-$_SENTAKU_MIN_SHOW}
  _s_header=
  _s_noheader=${SENTAKU_NOHEADER:-$_SENTAKU_NOHEADER}
  _s_nonumber=${SENTAKU_NONUMBER:-$_SENTAKU_NONUMBER}
  _s_showlast=${SENTAKU_SHOWLAST:-$_SENTAKU_SHOWLAST}
  _s_search_opt=${SENTAKU_SEARCH_OPT:-$_SENTAKU_SEARCH_OPT}
  _s_page_change=${SENTAKU_PAGE_CHANGE:-$_SENTAKU_PAGE_CHANGE}
  _s_keymode=${SENTAKU_KEYMODE:-$_SENTAKU_KEYMODE}
  _s_col_n_only=${SENTAKU_COLOR_NUM_ONLY:-$_SENTAKU_COLOR_NUM_ONLY}
  _s_line_highlight=${SENTAKU_LINE_HIGHLIGHT:-$_SENTAKU_LINE_HIGHLIGHT}
  _s_debug=${SENTAKU_DEBUG:-$_SENTAKU_DEBUG}
  _s_show=
  _s_lines=0
  _s_cols=0
  _s_max_show=0
  _s_stdin=0
  _s_align=0
  _s_delete=0
  _s_continue=0
  _s_noshow=0
  _s_trapped=0
  _s_normal_echo=${_s_normal_echo:-1}

  _s_is_print=1

  _s_ext_row=0
  _s_current_n=-1
  _s_num=""
  _s_n_offset=0
  _s_g=0
  _s_n_move=-1

  ## @var _sentaku_visual
  ##   _sentaku_visual=-1 ... single selection mode
  ##   _sentaku_visual=-2 ... visual selection mode
  ##   _sentaku_visual>=0 ... visual selection mode (currently selecting)
  _sentaku_visual=-1
  _sentaku_visual_list=()

  _s_break=0
  _s_search=""
  _s_search_words=""
  _s_pre_inputs_n=0
  eval '_s_pre_inputs_'{0..999}'=();'
  _s_read=
  _s_zsh_ksharrays=0
  _s_stty=
  _s_IFS=$IFS

  _s_ret=0

  # Help
  _s_help=${_s_help:-"Usage: sentaku [-HNladnh] [-f <file>] [-s <sep>] [input variables]

Arguments:
  -f <file>  Set input file
  -s <sep>   Set separtor (default: ${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR})
             If <sep> is \"line\", \$'\\n' is set as a separator.
  -H         Force to show a header at sentaku window.
  -N         No nubmers are shown.
  -U         Use underline to show selected line, instead of highlighting.
  -l         Show last words instead of starting words for longer lines.
  -a         Align input list (set selected one to the first).
  -r <n>     Return nth value directly.
  -p         Push words to the file.
  -E         Use Emacs mode
  -V         Use Vmacs mode
  -c         Load functions as a child process in other sentaku process.
  -n         Don't run functions, to just source this file
  -v         Show version
  -h         Print this HELP and exit

Key operation at sentaku window
  Common for all:
    C-p/C-n  Up/Down.
    C-u/C-d  Half page down/Half page down.
    C-b/C-f  Page up/Page down.
    M-v/C-v  Page up/Page down.
    C-a/C-e  Go to the beggining/end.
    C-i/C-o  Move the item up/down.
    C-x      Quit.
    C-s      Start/Stop Visual mode (multi-selection).
    Space    Select/unselect current line for multi-selection.
             At Emacs mode or search mode in Vim mode,
             it selects when space is pushed twice.
    Esc      At search mode, first Esc takes it back to normal mode
             with selected words.
             Second Esc clear search mode.
             Visual mode is cleared by first Esc.
    Ener     Select and Quit.

  For Vim mode:
    n(any number) Set number. Multi-digit can be used (13, 320, etc...).
                  Used/reset by other key.
    k/j      Up/Down (if n is given, n-th up/n-th down).
    gg/G     Go to top/bottom. (If n is given, move to n-th candidate.)
    d        Delete current candidate. (in case you use input file.)
    s        Show detail of current candidate.
    v        Visual mode, same as C-s
    /        Search.
    q        Quit.
    Others   Nothing happens.

  For Emacs mode:
    Others   Normal keys start an incremental search.
"}

  # Lines and columns at beginning
  _s_lines=$(tput lines)
  _s_cols=$(tput cols)

  # Fix array for zsh
  if [[ -n "$ZSH_VERSION" ]];then
    if ! setopt | grep -q ksharrays;then
      _s_zsh_ksharrays=1
      setopt ksharrays
    fi
  fi

  # Check std input
  [[ ! -t 0 ]] && _s_stdin=1

  # User initialization
  sentaku/INITIALIZE
} # }}}

function sentaku/INITIALIZE {
  :
}

function sentaku/list#clear {
  _sentaku_visual_list=()
}
function sentaku/list#set {
  local -i index=$1 arg=$2
  if ((arg)); then
    _sentaku_visual_list[index]=$arg
  else
    unset '_sentaku_visual_list[index]'
  fi
}


function sentaku/finalize {
  IFS=$_s_IFS

  if ((_s_ret==0&&_s_current_n>=0));then
    # Align values
    if [[ $_s_search ]];then
      local -a selected
      selected=()
      IFS=$_s_s
      if ((_sentaku_visual!=-1)); then
        local is_first=1
        local i
        local j=0
        for i in "${!_sentaku_visual_list[@]}"; do
          selected[j++]=${_s_inputs[i]}
        done
      fi
      _s_inputs=("${_s_pre_inputs_0[@]}")
      IFS=$_s_IFS
      _s_n=${#_s_inputs[@]}
      if ((_sentaku_visual!=-1)); then
        sentaku/list#clear
      fi
      _s_current_n=0
      if ((_sentaku_visual!=-1)); then
        local i
        local j
        for ((i=0;i<_s_n;i++)); do
          for ((j=0;j<${#selected[@]};j++)); do
            if [[ ${selected[j]} = "${_s_inputs[i]}" ]]; then
              _s_current_n=$i
              _sentaku_visual_list[i]=1
            fi
          done
        done
      else
        local val=${_s_inputs[_s_current_n]}
        local i
        for ((i=0;i<_s_n;i++)); do
          if [[ $val = "${_s_inputs[$i]}" ]]; then
            _s_current_n=$i
            break
          fi
        done
      fi
      _s_search=
    fi

    # Execution for selected value
    sentaku/execute

    [[ "$_s_align" -eq 1 && "$_s_stdin" -eq 0 ]] &&\
      _sf_align_values "$_s_current_n" 0
  fi

  if [[ "$_SENTAKU_CHILD" -eq 0 && "$_s_noshow" -eq 0 ]];then
    # Show cursor
    tput cnorm >/dev/tty 2>/dev/null || tput vs >/dev/tty 2>/dev/null

    # Enable echo input
    if [[ $_s_stdin -eq 0 ]];then
      if [[ "$_s_stty" != "" ]];then
        stty $_s_stty
        # followings are for fixing problems of previous commands...
        stty echo
      fi
    fi
  fi
  if [[ $_s_trapped -eq 1 ]];then
    # fixed at C-c
    stty echo 2>/dev/null
  fi

  # Release variables
  unset _s_file
  unset _s_use_file
  unset _s_s
  unset _s_s_push
  unset _s_inputs
  unset _s_cmd_line_inputs
  unset _s_n
  unset _s_max
  unset _s_min_show
  unset _s_header
  unset _s_noheader
  unset _s_nonumber
  unset _s_showlast
  unset _s_search_opt
  unset _s_page_change
  unset _s_keymode
  unset _s_col_n_only
  unset _s_line_highlight
  unset _s_debug
  unset _s_show
  unset _s_lines
  unset _s_cols
  unset _s_max_show
  unset _s_stdin
  unset _s_align
  unset _s_delete
  unset _s_continue
  unset _s_noshow
  unset _s_trapped
  unset _s_normal_echo

  unset _s_is_print

  unset _s_ext_row
  unset _s_current_n
  unset _s_num
  unset _s_n_offset
  unset _s_g
  unset _s_n_move
  unset _sentaku_visual
  unset _sentaku_visual_list
  unset _s_break
  unset _s_search
  unset _s_search_words
  unset _s_pre_inputs_n
  unset _s_pre_inputs_{0..999}
  unset _s_read

  unset _s_help

  [[ "x$_s_zsh_ksharrays" != "x" && $_s_zsh_ksharrays -eq 1 ]] && unsetopt ksharrays
  unset _s_zsh_ksharrays

  unset _s_is_noexec
  unset _s_is_help
  unset _s_is_file
  unset _s_is_main
  unset _s_is_push
  unset _s_stty
  unset _s_IFS

  sentaku/FINALIZE

  local ret=$_s_ret
  unset _s_ret
  return $ret
}

function sentaku/FINALIZE {
  :
}

function sentaku/execute {
  if ((_sentaku_visual!=-1));then
    local is_first=1
    local i
    for i in "${!_sentaku_visual_list[@]}"; do
      if [[ $is_first ]]; then
        printf "%s" "${_s_inputs[i]}"
        is_first=
      else
        printf "$_s_s%s" "${_s_inputs[i]}"
      fi
    done
  else
    printf "%s" "${_s_inputs[$_s_current_n]}"
  fi
}

function sentaku/hide {
  if [[ "$_SENTAKU_CHILD" -eq 0 && "$_s_noshow" -eq 0 ]];then
    if [[ $_s_stdin -eq 0 ]];then
      # Save current stty
      _s_stty=$(stty -g)

      # Hide any input
      stty -echo

    fi

    # Hide cursor
    tput civis >/dev/tty 2>/dev/null || tput vi >/dev/tty 2>/dev/null

    # Save current display
    tput smcup >/dev/tty 2>/dev/null || tput ti >/dev/tty 2>/dev/null

    _s_normal_echo=0
  fi
}

function sentaku/clear {
  if [[ "$_SENTAKU_CHILD" -eq 0 && "$_s_noshow" -eq 0 ]];then
    # clear after selection
    clear >/dev/tty

    # Restore display
    tput rmcup >/dev/tty 2>/dev/null || tput te >/dev/tty 2>/dev/null

    _s_normal_echo=1
  fi
}

function sentaku/util/nth {
  local -i arg=$1
  local digit=$arg
  ((digit<0)) && ((digit=-digit))
  ((digit>=20)) && ((digit%=10))
  case $digit in
  (1) ret=${arg}st ;;
  (2) ret=${arg}nd ;;
  (3) ret=${arg}rd ;;
  (*) ret=${arg}th ;;
  esac
}

#------------------------------------------------------------------------------
# mode: sentaku/pause

function ble/widget/sentaku_pause/exit { ble-decode/keymap/pop; }
function ble-decode/keymap:sentaku_pause/define {
  local ble_bind_keymap=sentaku_pause
  ble-bind -f __default__ sentaku_pause/exit
}
function sentaku/pause {
  ble-decode/keymap/push sentaku_pause
}

#------------------------------------------------------------------------------
# mode: sentaku/yn

function ble/widget/sentaku_yn/__before_widget__ {
  clear >/dev/tty
  echo "$message [y/n]: " >/dev/tty
}
function ble/widget/sentaku_yn/yes {
  ble-decode/keymap/pop
  true
  eval "$_sentaku_yn_callback"
}
function ble/widget/sentaku_yn/no {
  ble-decode/keymap/pop
  ble/widget/sentaku/quit # ???
  false
  eval "$_sentaku_yn_callback"
}
function ble-decode/keymap:sentaku_yn/define {
  local ble_bind_keymap=sentaku_tn
  ble-bind -f __default__ nop
  ble-bind -f __before_widget__ sentaku_yn/__before_widget__
  ble-bind -f y sentaku_yn/yes
  ble-bind -f n sentaku_yn/no
}

_sentaku_yn_callback=
function sentaku/yn {
  _sentaku_yn_callback=$1; shift
  local message="$*"
  ble-decode/keymap/push sentaku_yn
  return 148
}

#------------------------------------------------------------------------------

function sentaku/check-args {
  # Get arguments
  _s_continue=0
  while (($#)); do
    case $1 in
    ("-f"|"-F") # Use file
      _s_file=$2
      _s_use_file=1
      if [[ ! $_s_file ]];then
        echo "ERROR: empty input was given with -i" >/dev/tty
        return 1
      fi
      shift ;;
    ("-s") # Set separator
      _s_s=$2
      if [[ $_s_s == line ]];then
        _s_s=$'\n'
      fi
      if [[ $_s_s = $' \t\n' ]];then
        _s_s_push=' '
      else
        _s_s_push=$_s_s
      fi
      shift ;;
    ("-H") _s_noheader=0;;
    ("-N") _s_nonumber=1;;
    ("-U") _s_line_highlight=0;;
    ("-l") _s_showlast=1;;
    ("-a") _s_align=1;;
    ("-m") ;;
    ("-r")
      if [[ "$2" =~ ^[0-9]+$ ]];then
        _s_current_n=$2
        shift
      else
        echo "-r option requires a number" >/dev/tty
        return 1
      fi
      ;;
    ("-p")
      shift
      sentaku/push "$@"
      return $? ;;
    ("-E") _s_keymode=1;;
    ("-V") _s_keymode=0;;
    ("-c") _SENTAKU_CHILD=1;;
    ("-v") echo "$(basename "$0") $SENTAKU_VERSION $SENTAKU_DATE" >/dev/tty; return 0;;
    ("-h")
      sentaku/help
      return 0 ;;
    (-*)
      echo "$(basename "$0") $1: unknown argument
Check \"$(basename "$0" ) -h\" for further information" >/dev/tty
      return 1
      ;;
    (*)
      break ;;
    esac
    shift
  done
  _s_cmd_line_inputs="$*"
  _s_continue=1
  return 0
}

function sentaku/push {
  # Set input
  local input="$*"
  shift $#
  if ((_s_stdin==1)); then
    input=$(cat -)
  fi

  # Ignore blank
  if [[ ! $input ]]; then
    return 1
  fi

  # Renew values
  sentaku/get-values 0 0
  IFS=$_s_s_push
  _s_inputs=(${input}${_s_s_push}${_s_inputs[@]})
  IFS=$_s_IFS
  _s_n=${#_s_inputs[@]}
  _sf_align_values 0 0

  sentaku/echoln "$input is stored in $_s_file"
}

## @fn sentaku/get-values [<is_stdin> [<is_check>]]
function sentaku/get-values {
  sentaku/get-values.impl "$1" "$2"
  if ((_s_n==0)); then
    return 1
  else
    sentaku/setview
  fi
}

## @fn sentaku/get-values.impl [<is_stdin> [<is_check>]]
function sentaku/get-values.impl {
  local stdin=$_s_stdin
  local check=1
  if [[ "$1" != "" ]];then
    stdin=$1
  fi
  if [[ "$2" != "" ]];then
    check=$2
  fi
  # Get values
  IFS="$_s_s"
  if [[ "$stdin" -eq 0 || "$_s_use_file" -eq 1 ]];then
    if [[ "$_s_use_file" -eq 0 && -z "$_s_file" ]];then
      _s_inputs=($(echo "$_s_cmd_line_inputs"))
    else
      touch "$_s_file"
      _s_inputs=($(< "$_s_file"))
    fi
  else
    _s_inputs=($(cat -))
  fi
  IFS=$_s_IFS
  if [[ -n "$ZSH_VERSION" ]];then
    # Fix array for ZSH
    # Zsh's array adds additional empty value to array if IFS is in the end of file.
    if [[ ${#_s_inputs[@]} -gt 0 ]];then
      local last="${_s_inputs[$((${#_s_inputs[@]}-1))]}"
      if [[ "${#last}" -eq 0 ]];then
        _s_inputs=(${_s_inputs[0,$((${#_s_inputs[@]}-2))]})
      fi
    fi
  fi
  _s_n=${#_s_inputs[@]}

  if [[ "$check" -eq 1 && "$_s_n" -eq 0 ]];then
    if [[ "$stdin" -eq 0 || "$_s_use_file" -eq 1 ]];then
      sentaku/echoln "No value in $_s_file\\n"
    else
      sentaku/echoln "No value in stdin\\n"
    fi
    _s_ret=1
    return
  elif ((_s_n>0)); then
    sentaku/list#clear
  fi
  _s_ret=0
}

function sentaku/align-values () { # {{{ sentaku/align-values [<n> [<is_get>]]
  local n=${1:-$_s_current_n}
  local is_get=${2:-1}
  if [[ ! $n =~ ^[0-9]+$ || n -ge _s_n ]];then
    sentaku/echoln "$n is not valid for sentaku/align-values"
    return 1
  fi
  local v="${_s_inputs[$n]}"
  printf "%s$_s_s_push" "$v" > "$_s_file"
  local i
  for ((i=0;i<_s_n;i++)); do
    ((i>=_s_max)) && break
    if [[ ${_s_inputs[i]} != "$v" ]]; then
      printf "%s$_s_s_push" "${_s_inputs[$i]}" >> "$_s_file"
    fi
  done
  if ((is_get==1)); then
    sentaku/get-values
  fi
} # }}}

function sentaku/string#add-spaces { # {{{ sentaku/string#add-spaces <var> <n> [is_prepend]
  local var=$1
  local n=$2
  local prepend=${3:-0}
  while ((n>0));do
    if ((prepend==1));then
      eval "$var=\" \$$var\""
    else
      eval "$var=\"\$$var \""
    fi
    ((n--))
  done
}

## @fn sentaku/string#cut-word <var> <max_length> [<is_last_show>]
function sentaku/string#cut-word {
  local var=$1
  local max_length=$2
  local is_last_show=${3:-0}
  local _value=${!var}
  if ((${#_value}<=max_length)); then
    sentaku/string#add-spaces _value $((max_length-${#_value}))
  elif ((is_last_show==0)); then
    _value=${_value::max_length}
  else
    _value=${_value:${#_value}-max_length}
    return
  fi
  eval "$var=\$_value"
  return
} # }}}

## sentaku/show [<is_selected>] [<n_show>]
function sentaku/show {
  local is_selected=${1:-0}
  local n_show=${2:-$_s_cols}
  sentaku/string#cut-word _s_show "$n_show" "$_s_showlast"

  # Color search words
  if [[ "$_s_search_words" != "" ]];then
    local ignore_case=0
    local search_words=$_s_search_words
    if [[ "$_s_search_opt" -eq 0 ]] || [[ "$_s_search_opt" -eq 2 ]];then
      if [[ -n "$ZSH_VERSION" ]];then
        local words_lower=$_s_search_words:l
      elif [[ -n ${BASH_VERSINFO[0]} ]] && [[ ${BASH_VERSINFO[0]} -ge 4 ]];then
        local words_lower=${_s_search_words,,}
      else
        local words_lower=$(echo ${_s_search_words}|tr "[:upper:]" "[:lower:]")
      fi
      if [[ $words_lower = "$_s_search_words" ]];then
        local ignore_case=1
        search_words=$words_lower
      fi
    fi

    local negative=""
    if [[ "$is_selected" -eq 1 ]];then
      negative=";7"
    fi

    if [[ "$_s_search_opt" -le 1 ]];then
      local -a words
      words=($search_words)
      local w
      for w in "${words[@]}";do
        if [[ $ignore_case -eq 1 ]];then
          # Similar replace can be done by GNU sed, BSD sed doesn't support ignore case option
          _s_show=$(echo "$_s_show"|perl -pe "s|($w)|\\e[31${negative}m\\1\\e[0${negative}m|gi")
        else
          _s_show="${_s_show//$w/\\e[31${negative}m$w\\e[${negative}m}"
        fi
      done
    else
      if [[ $ignore_case -eq 1 ]];then
        _s_show=$(echo "$_s_show"|perl -pe "s|(^$search_words)|\\e[31${negative}m\\1\\e[0${negative}m|gi")
      else
        _s_show="\\e[31${negative}m$search_words\\e[${negative}m${_s_show#$search_words}"
      fi
    fi
  fi
}

function sentaku/printline { # useage: sentaku/printline is_selected n_line n_input {{{
  local is_selected=$1
  local n_line=$2
  local n_input=$3

  local color=""
  if [[ ${_sentaku_visual_list[n_input]} ]];then
    color="[36m"
  fi
  if [[ "$is_selected" -eq 1 ]];then
    if [[ "$_s_line_highlight" -eq 1 ]];then
      color="${color}[7m"
    else
      color="${color}[4m"
    fi
  fi

  # Change line breaks to \n (to be shown), remove the last line break, replace tab to space
  _s_show=${_s_inputs[$n_input]//$'\n'/\\\\n}
  _s_show=${_s_show%\\\\n}
  _s_show=${_s_show//$'\t'/ }

  tput cup "$n_line" 0 >/dev/tty
  local n_show=$_s_cols
  _s_num=""
  if [[ $_s_nonumber -eq 0 ]];then
    local nmax=$((_s_n-1))
    local num_width=${#nmax}
    n_show=$((_s_cols-num_width-2))
    sentaku/string#add-spaces _s_num $((num_width-${#n_input})) 1
    _s_num="$_s_num$n_input: "
  fi
  sentaku/show "$is_selected" "$n_show"
  if [[ "$_s_col_n_only" -eq 1 ]];then
    printf "${color}${_s_num}[m${_s_show}" >/dev/tty
  else
    printf "${color}${_s_num}${_s_show}[m" >/dev/tty
  fi
  tput cup "$n_line" 0 >/dev/tty
}

## print current line
function sentaku/print_current_line {
  sentaku/printline 1 $((_s_current_n-_s_n_offset+_s_ext_row)) $_s_current_n
}

## usage: sentaku/printall [not force]
function sentaku/printall {
  # if any argument is given, check if echoed or not.
  if [[ $# -ge 1 && $_s_is_print -eq 0 ]];then
    return
  fi

  local lines=$_s_lines
  local cols=$_s_cols
  _s_lines=$(tput lines)
  _s_cols=$(tput cols)

  sentaku/setview

  if [[ "$lines" -ne "$_s_lines" || "$cols" -ne "$_s_cols" ]];then
    _s_current_n=0
    _s_n_offset=0
  fi

  clear >/dev/tty

  # Header
  sentaku/util/print "${_s_header}"

  local i
  for i in $(seq 0 $((_s_max_show-1)));do
    if [[ $((i+_s_n_offset)) -ge "$_s_n" ]];then break;fi
    if [[ $((i+_s_n_offset)) -eq $_s_current_n ]];then
      sentaku/print_current_line
    else
      sentaku/printline 0 $((i+_s_ext_row)) $((i+_s_n_offset))
    fi
  done
  _s_is_print=0
}

function sentaku/util/print { # {{{
  printf "%b" "$*" >/dev/tty
}

function sentaku/echo {
  if [[ $_s_noshow -eq 1 ]];then
    :
  elif [[ $_s_normal_echo -eq 1 ]];then
    sentaku/util/print "$*"
  else
    clear >/dev/tty
    sentaku/util/print "$*"
    _s_is_print=1
    sentaku/pause
  fi
}

function sentaku/echoln {
  sentaku/echo "$*\\n"
}

function sentaku/echo-debug {
  if [[ ! $_s_debug ]]; then
    # Temporarily use default value for debug_echo before initialization.
    _s_debug=$_SENTAKU_DEBUG
  fi
  if ((_s_debug>0)); then
    sentaku/echo "$*"
  fi
}

function sentaku/echoln-debug {
  sentaku/echo-debug "$*\\n"
}

function sentaku/echo-printall {
  sentaku/echo "$*"
  sentaku/printall
}

function sentaku/set-header {
  _s_header="\\e[43;30m$_s_n values in total\\e[0m "
  if [[ "$_s_noheader" = 1 ]];then
    return
  fi
  if [[ $_s_delete -eq 1 ]];then
    local delete_key="d(delete), "
  else
    local delete_key=""
  fi
  if [[ $_s_keymode -eq 0 ]];then
    if [[ "$_s_cols" -ge 68 ]];then
      _s_header="$_s_header
  [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n)
  ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up)
  ${delete_key}/(search), Enter/Space(select), q(quit)"
    elif [[ "$_s_cols" -ge 41 ]];then
      _s_header="$_s_header
  vimike updown, e.g)j:down, k:up, gg/G
  ${delete_key}Enter/Space(select), q(quit)"
    fi
  else
    if [[ "$_s_cols" -ge 51 ]];then
      _s_header="$_s_header
  C-n(down), C-j(up), C-v(Page down), M-v(Page up)
  Enter(select), C-x(quit)
  Other normal keys start an incremental search"
    fi
  fi
}  # }}}

function sentaku/setview {
  if ((_s_lines<=_s_min_show)); then
    _s_header=
    _s_ext_row=0
  elif ((_s_lines==_s_min_show+1)); then
    _s_header=${_s_search}
    _s_ext_row=1
  else
    sentaku/set-header
    _s_header="$_s_header\\n$_s_search"
    if (($(printf "%b\n" "$_s_header"|grep -c ^)>_s_lines-_s_min_show)); then
      _s_header="\e[43;30m$_s_n values in total\e[0m\n${_s_search}"
    fi
    _s_ext_row=$(printf "%b\n" "$_s_header"|grep -c ^)
  fi

  _s_max_show=$_s_n
  if [[ "$_s_n" -gt $((_s_lines-_s_ext_row)) ]];then
    _s_max_show=$((_s_lines-_s_ext_row))
  fi
}

function ble/widget/sentaku/quit {
  [[ $# -gt 0 ]] && _s_ret=$1
  _s_current_n=-1
  _s_break=1
}
function ble/widget/sentaku/select {
  _s_break=1
}

function sentaku/reset {
  _s_current_n=0
  _s_n_offset=0
  _s_g=0
  _s_n_move=-1
  _sentaku_visual=-1
  sentaku/list#clear
  tput cup "$_s_ext_row" 0 >/dev/tty
  sentaku/printall
}

#------------------------------------------------------------------------------
# moves

function sentaku/move-down { # The line goes Down. (Increase the line number) {{{
  ((_s_n_move<=0)) && _s_n_move=1
  local all=0
  local old_current_n=$_s_current_n
  local old_cursor_r=$((_s_current_n-_s_n_offset+_s_ext_row))
  _s_current_n=$((_s_current_n+_s_n_move))
  ((_s_current_n>=_s_n)) && ((_s_n_move=-1,_s_current_n=_s_n-1))
  if ((_s_current_n==old_current_n)); then
    _s_g=0
    _s_n_move=-1
  fi
  if ((_s_current_n+1-_s_max_show>_s_n_offset)); then
    if ((_s_page_change==0)); then
      ((_s_n_offset=_s_current_n+1-_s_max_show))
    else
      ((_s_n_offset=_s_current_n-_s_current_n%_s_max_show))
    fi
    all=1
  fi
  if ((all==1)); then
    _s_is_print=1
  elif ((_sentaku_visual<0)); then
    sentaku/printline 0 $old_cursor_r $old_current_n
    sentaku/print_current_line
  fi
  if ((_sentaku_visual>=0)); then
    local tmp_r=$old_cursor_r
    local tmp_n=$old_current_n
    while ((tmp_n<_s_current_n)); do
      sentaku/list#set "$tmp_n" $((tmp_n<_sentaku_visual?0:1))
      ((all!=1)) && sentaku/printline 0 $tmp_r $tmp_n
      ((tmp_r++,tmp_n++))
    done
    _sentaku_visual_list[_s_current_n]=1
    ((all!=1)) && sentaku/print_current_line
  fi
  _s_g=0
  _s_n_move=-1
}

function sentaku/move-up { # The line goes up. (Decrease the line Number!) {{{
  ((_s_n_move<=0)) && _s_n_move=1
  local all=0
  local old_current_n=$_s_current_n
  local old_cursor_r=$((_s_current_n-_s_n_offset+_s_ext_row))
  _s_current_n=$((_s_current_n-_s_n_move))
  ((_s_current_n<0)) && _s_current_n=0
  if ((_s_current_n==old_current_n));then
    _s_g=0
    _s_n_move=-1
  fi
  if ((_s_current_n<_s_n_offset)); then
    if ((_s_page_change==0)); then
      ((_s_n_offset=_s_current_n))
    else
      ((_s_n_offset=_s_current_n-_s_current_n%_s_max_show))
    fi
    all=1
  fi
  if ((all==1)); then
    _s_is_print=1
  elif ((_sentaku_visual<0)); then
    sentaku/printline 0 $old_cursor_r $old_current_n
    sentaku/print_current_line
  fi
  if ((_sentaku_visual>=0)); then
    local tmp_r=$old_cursor_r
    local tmp_n=$old_current_n
    while ((tmp_n>_s_current_n)); do
      sentaku/list#set "$tmp_n" $((tmp_n>s_visual?1:0))
      ((all!=1)) && sentaku/printline 0 $tmp_r $tmp_n
      ((tmp_r--,tmp_n--))
    done
    _sentaku_visual_list[_s_current_n]=1
    ((all!=1)) && sentaku/print_current_line
  fi
  _s_g=0
  _s_n_move=-1
}

function ble/widget/sentaku/append-arg {
  local n=${1:-0}
  ((_s_n_move=_s_n_move>0?_s_n_move*10+n:n))
}

function ble/widget/sentaku/forward-item { sentaku/move-down; }
function ble/widget/sentaku/backward-item { sentaku/move-up; }
function ble/widget/sentaku/page-up {
  ((_s_n_move=_s_max_show))
  sentaku/move-up
}
function ble/widget/sentaku/page-down {
  ((_s_n_move=_s_max_show))
  sentaku/move-down
}
function ble/widget/sentaku/half-page-down {
  ((_s_n_move=_s_max_show/2))
  sentaku/move-down
}
function ble/widget/sentaku/half-page-up {
  ((_s_n_move=_s_max_show/2))
  sentaku/move-up
}

function sentaku/goto {
  ((_s_n_move=_s_n_move-_s_current_n))
  ((_s_n_move==0)) && return
  if ((_s_n_move<0)); then
    ((_s_n_move=-_s_n_move))
    sentaku/move-up
  else
    sentaku/move-down
  fi
}
function ble/widget/sentaku/goto-line-or-top {
  if ((_s_g==0)); then
    _s_g=1
    return
  fi
  ((_s_n_move<0)) && _s_n_move=0
  sentaku/goto
}
function ble/widget/sentaku/goto-line-or-end {
  ((_s_n_move<0)) && _s_n_move=$_s_n
  sentaku/goto
}
# function for <C-a>-<C-Z>, <C-Space>
function ble/widget/sentaku/goto-top {
  _s_n_move=0
  sentaku/goto
  #local i
  #for ((i=0;i<_s_n;i++)); do
  #  _sentaku_visual=-2
  #  _sentaku_visual_list[i]=1
  #done
  #_s_is_print=1
}
function ble/widget/sentaku/goto-end {
  _s_n_move=$_s_n
  sentaku/goto
}

#------------------------------------------------------------------------------
# edit items

function sentaku/delete {
  : >| "$_s_file"
  local i
  local old_current_n=$_s_current_n
  for ((i=0;i<_s_n;i++)); do
    if ((_sentaku_visual!=-1&&_sentaku_visual_list[i]||_sentaku_visual==-1&&i==old_current_n)); then
      ((i<old_current_n&&_s_current_n--))
      continue
    fi
    printf "%s$_s_s_push" "${_s_inputs[$i]}" >> "$_s_file"
  done
  sentaku/get-values
}

function sentaku/remove {
  local old_current_n=$_s_current_n
  if ((_sentaku_visual!=-1)); then
    local i
    for i in "${!_sentaku_visual_list[@]}"; do
      unset '_s_inputs[i]'
      ((i<old_current_n&&_s_current_n--))
    done
  else
    unset '_s_inputs[_s_current_n]'
  fi
  _s_inputs=("${_s_inputs[@]}")
  _s_n=${#_s_inputs[@]}
  sentaku/list#clear
}

function ble/widget/sentaku/raise-item {
  ((_s_current_n==0)) && return

  ((_s_n_move<=0)) && _s_n_move=1

  local replace=$((_s_current_n-_s_n_move))
  ((replace<0)) && replace=0

  local v_current=${_s_inputs[$_s_current_n]}
  local v_replace=${_s_inputs[$replace]}
  _s_inputs[$_s_current_n]=$v_replace
  _s_inputs[$replace]=$v_current
  [[ $_s_stdin -eq 0 ]] && sentaku/align-values 0 0
  sentaku/printall
  sentaku/move-up
}
function ble/widget/sentaku/lower-item {
  ((_s_current_n==_s_n-1)) && return

  ((_s_n_move<=0)) && _s_n_move=1

  local replace=$((_s_current_n+_s_n_move))
  ((replace>_s_n-1)) && replace=$((_s_n-1))

  local v_current=${_s_inputs[_s_current_n]}
  local v_replace=${_s_inputs[replace]}
  _s_inputs[_s_current_n]=$v_replace
  _s_inputs[replace]=$v_current
  ((_s_stdin==0)) && sentaku/align-values 0 0
  sentaku/printall
  sentaku/move-down
}
function ble/widget/sentaku/delete-item {
  local old_current_n=$_s_current_n
  if ((_s_delete==0||_s_stdin==1)); then
    sentaku/remove
  else
    sentaku/delete
  fi
  if ((_s_n==0)); then
    sentaku/echoln "There are no remained entries"
    _s_ret=1
  fi
  if ((_s_ret));then
    ble/widget/sentaku/quit $_s_ret
    return
  fi
  if ((_s_current_n>=_s_n)); then
    ((_s_current_n=_s_n-1))
  fi
  if ((_s_current_n<_s_n_offset)); then
    _s_n_offset=$_s_current_n
  fi
  local n_move
  if ((_s_n<_s_lines-_s_ext_row+_s_n_offset)); then
    local n_move=$((_s_lines-_s_ext_row+_s_n_offset-_s_n))
    if ((n_move>_s_n_offset)); then
      n_move=$_s_n_offset
    fi
    ((_s_n_offset=_s_n_offset-n_move))
  fi
  _sentaku_visual=-1
  sentaku/list#clear
  _s_is_print=1
}

#------------------------------------------------------------------------------
# mode: sentaku/search

function sentaku/search/update {
  local opts=$1
  _s_search="\e[41;30mSearch:\e[0m \e[31m$_s_search_words\e[0m"

  if [[ ! $_s_search_words ]];then
    _s_inputs=("${_s_pre_inputs_0[@]}")
    _s_n=${#_s_inputs[@]}
  elif [[ :$opts: == *:delete:* ]];then
    :
  else
    local -a inputs
    inputs=()
    local i j=0
    for ((i=0;i<_s_n;i++)); do
      if sentaku/search/check "${_s_inputs[i]}";then
        inputs[j]=${_s_inputs[$i]}
        ((j++))
      fi
    done
    _s_inputs=("${inputs[@]}")
    _s_n=${#_s_inputs[@]}
    ((_s_pre_inputs_n++))
    eval "_s_pre_inputs_${_s_pre_inputs_n}=(\"\${_s_inputs[@]}\")"
  fi

  sentaku/reset
}
function sentaku/search/check {
  local input="$1"
  local search_words=$_s_search_words

  if ((_s_search_opt==0||_s_search_opt==2)); then
    local ret
    ble/string#tolower "$input"; local input_lower=$ret
    ble/string#tolower "$_s_search_words"; local words_lower=$ret
    if [[ $words_lower == "$_s_search_words" ]]; then
      input=$input_lower
      search_words=$words_lower
    fi
  fi
  if ((_s_search_opt<=1)); then
    local -a words
    words=(${search_words})
    local w
    for w in "${words[@]}";do
      if ((_s_search_opt<=1)); then
        if [[ $input != *"$w"* ]];then
          return 1
        fi
      fi
    done
  else
    if [[ $input != "$search_words"* ]];then
      return 1
    fi
  fi
  return 0
}

function ble/widget/sentaku_search/backspace {
  if [[ ! $_s_search_words ]]; then
    _s_search=
    _s_search_words=
    sentaku/reset
    ble-decode/keymap/pop
    return
  fi
  sentaku/string#cut-word _s_search_words $((${#_s_search_words}-1))
  ((_s_pre_inputs_n--))
  eval "_s_inputs=(\"\${_s_pre_inputs_$((_s_pre_inputs_n))[@]}\")"
  _s_n=${#_s_inputs[@]}
  sentaku/search/update delete
}
function ble/widget/sentaku_search/accept {
  ble/widget/sentaku/select
  ble-decode/keymap/pop
}
function ble/widget/sentaku_search/self-insert {
  local ret; ble/util/c2s "${KEYS[0]}"
  _s_search_words=$_s_search_words$ret
  sentaku/search/update
}
function ble/widget/sentaku_search/clear {
  _s_search_words=""
  _s_pre_inputs_n=0
  sentaku/search/update
}
function ble/widget/sentaku_search/cancel {
  if ((_s_n==0||_s_keymode==1)); then
    _s_inputs=("${_s_pre_inputs_0[@]}")
    _s_n=${#_s_inputs[@]}
    _s_search=
    _s_search_words=
    sentaku/reset
  fi
  ble-decode/keymap/pop
}

function ble-decode/keymap:sentaku_search/define {
  local ble_bind_keymap=sentaku_search

  ble-bind -f __default__ nop
  ble-bind -f __defchar__ sentaku_search/self-insert

  ble-bind -f 'C-a' sentaku/goto-top
  ble-bind -f 'C-b' sentaku/page-up
  ble-bind -f 'C-d' sentaku/half-page-down
  ble-bind -f 'C-e' sentaku/goto-end
  ble-bind -f 'C-f' sentaku/page-down
  ble-bind -f 'C-n' sentaku/forward-item
  ble-bind -f 'C-p' sentaku/backward-item
  ble-bind -f 'C-i' sentaku/raise-item
  ble-bind -f 'C-o' sentaku/lower-item
  ble-bind -f 'C-r' sentaku/redraw
  ble-bind -f 'C-s' sentaku/start-visual
  ble-bind -f 'C-u' sentaku/half-page-up
  ble-bind -f 'C-x' sentaku/quit

  ble-bind -f 'M-v' sentaku/page-up
  ble-bind -f 'C-v' sentaku/page-down
  ble-bind -f prior sentaku/page-up
  ble-bind -f next sentaku/page-down
  ble-bind -f up sentaku/backward-item
  ble-bind -f down sentaku/forward-item

  ble-bind -f 'C-h' sentaku_search/backspace
  ble-bind -f 'BS'  sentaku_search/backspace
  ble-bind -f 'C-?' sentaku_search/backspace
  ble-bind -f 'DEL' sentaku_search/backspace

  ble-bind -f C-j sentaku_search/accept
  ble-bind -f C-m sentaku_search/accept
  ble-bind -f RET sentaku_search/accept

  ble-bind -f C-u sentaku_search/clear
  ble-bind -f ESC sentaku_search/cancel
}

function ble/widget/sentaku/search {
  if ((_s_ext_row==0)); then
    sentaku/echo "Too few lines for search mode."
    return
  fi
  local first_char=$1
  if [[ ! $_s_search ]]; then
    _s_pre_inputs_0=("${_s_inputs[@]}")
    _s_pre_inputs_n=0
    _s_search="\e[41;30mSearch:\e[0m"
  fi
  
  if [[ ! $first_char ]]; then
    sentaku/printall
  fi
  _s_search_words="$_s_search_words$first_char"
  sentaku/search/update
  ble-decode/keymap/push sentaku_search
}

#------------------------------------------------------------------------------

function ble/widget/sentaku/start-visual {
  if ((_sentaku_visual>=0)); then
    _sentaku_visual=-2
  else
    _sentaku_visual_list[_s_current_n]=1
    _sentaku_visual=$_s_current_n
    sentaku/print_current_line
  fi
}
function ble/widget/sentaku/toggle {
  # Space to start visual
  sentaku/list#set "$_s_current_n" $((!_sentaku_visual_list[_s_current_n]))
  _sentaku_visual=-2
  sentaku/print_current_line
}

function ble/widget/sentaku/show {
  local ret; sentaku/util/nth "$_s_current_n"; local nth=$ret
  sentaku/echo "$nth value:

${_s_inputs[$_s_current_n]}\n"
}

function ble/widget/sentaku/redraw {
  _s_is_print=1
}

function ble/widget/sentaku/cancel {
  if ((_sentaku_visual!=-1)); then
    _sentaku_visual=-1
    sentaku/list#clear
    _s_is_print=1
  fi
  if [[ $_s_search ]];then
    _s_inputs=("${_s_pre_inputs_0[@]}")
    _s_n=${#_s_inputs[@]}
    _s_search=""
    _s_search_words=""
    sentaku/reset
  fi
}

function ble-decode/keymap:sentaku/define {
  local ble_bind_keymap=sentaku

  ble-bind -f __default__ nop

  if ((_s_keymode==0)); then
    ble-bind -f 0 'sentaku/append-arg 0'
    ble-bind -f 1 'sentaku/append-arg 1'
    ble-bind -f 2 'sentaku/append-arg 2'
    ble-bind -f 3 'sentaku/append-arg 3'
    ble-bind -f 4 'sentaku/append-arg 4'
    ble-bind -f 5 'sentaku/append-arg 5'
    ble-bind -f 6 'sentaku/append-arg 6'
    ble-bind -f 7 'sentaku/append-arg 7'
    ble-bind -f 8 'sentaku/append-arg 8'
    ble-bind -f 9 'sentaku/append-arg 9'
    ble-bind -f d 'sentaku/delete-item' 
    ble-bind -f g 'sentaku/goto-line-or-top'
    ble-bind -f G 'sentaku/goto-line-or-end'
    ble-bind -f j 'sentaku/forward-item'
    ble-bind -f k 'sentaku/backward-item'
    ble-bind -f q 'sentaku/quit'
    ble-bind -f s 'sentaku/show'
    ble-bind -f v 'sentaku/start-visual'
    ble-bind -f / 'sentaku/search'
  else
    function ble/widget/sentaku/self-insert {
      local ret; ble/util/c2s "${KEYS[0]}"
      ble/widget/sentaku/search "$ret"
    }
    ble-bind -f __defchar__ sentaku/self-insert
  fi

  ble-bind -f 'C-a' sentaku/goto-top
  ble-bind -f 'C-b' sentaku/page-up
  ble-bind -f 'C-d' sentaku/half-page-down
  ble-bind -f 'C-e' sentaku/goto-end
  ble-bind -f 'C-f' sentaku/page-down
  ble-bind -f 'C-n' sentaku/forward-item
  ble-bind -f 'C-p' sentaku/backward-item
  ble-bind -f 'C-i' sentaku/raise-item
  ble-bind -f 'C-o' sentaku/lower-item
  ble-bind -f 'C-r' sentaku/redraw
  ble-bind -f 'C-s' sentaku/start-visual
  ble-bind -f 'C-u' sentaku/half-page-up
  ble-bind -f 'C-x' sentaku/quit

  ble-bind -f SP  sentaku/toggle
  ble-bind -f C-j sentaku/select
  ble-bind -f C-m sentaku/select
  ble-bind -f RET sentaku/select

  ble-bind -f 'M-v' sentaku/page-up
  ble-bind -f 'C-v' sentaku/page-down
  ble-bind -f prior sentaku/page-up
  ble-bind -f next sentaku/page-down
  ble-bind -f up sentaku/backward-item
  ble-bind -f down sentaku/forward-item

  ble-bind -f delete sentaku/delete-item

  ble-bind -f ESC sentaku/cancel
}

function sentaku/main {
  # Set trap
  trap "sentaku/clear;_s_trapped=1;_s_stdin=0;_s_ret=1;sentaku/finalize;exit" HUP INT QUIT ABRT SEGV TERM

  # Initializatoin
  sentaku/initialize

  # Get arguments
  sentaku/check-args "$@"
  _s_ret=$?
  if ((_s_ret)); then
    sentaku/finalize
    return $?
  fi
  if ((_s_continue==0)); then
    sentaku/finalize
    return $?
  fi

  # Get values
  sentaku/get-values
  _s_ret=$?
  if ((_s_ret)); then
    sentaku/finalize
    return $?
  fi

  # Return nth
  if ((_s_current_n>=0)); then
    sentaku/finalize
    return $?
  fi

  local term_state=$_ble_term_state
  {
    [[ $term_state == external ]] && ble/term/enter

    # Hide displays
    sentaku/hide

    # Initialize values
    sentaku/reset

    sentaku/printall 1
    ble-decode/keymap/push sentaku
    while :; do
      local char ret
      IFS= builtin read -r -d '' -n 1 char; local ext=$?
      ble/util/s2c "$char"
      ble-decode-char "$ret"

      [[ $_ble_decode_keymap == sentaku || $_ble_decode_keymap == sentaku_search ]] &&
        ((_s_break==1)) && break
      [[ $_ble_decode_keymap == sentaku ]] &&
        sentaku/printall 1
    done
    ble-decode/keymap/pop

    # Clear (Show cursor, Restore display, Enable echo input)
    sentaku/clear

    [[ $term_state == external ]] && ble/term/leave
  } < /dev/tty > /dev/tty

  # Finalization
  sentaku/finalize
}

# Execution part
if [[ $1 != -n ]];then
  (sentaku/main "$@")
fi
