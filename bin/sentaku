#!/usr/bin/env bash

# Default values
_SENTAKU_INPUT_FILE="$HOME/.sentaku_input"
_SENTAKU_SEPARATOR=$'\n'
_SENTAKU_MAX=20
_SENTAKU_NOHEADER=1
_SENTAKU_NONUMBER=0
_SENTAKU_SHOWLAST=0

function _sf_nth () { # {{{
  if [ $1 -eq 1 ];then
    echo 1st
  elif [ $1 -eq 2 ];then
    echo 2nd
  elif [ $1 -eq 3 ];then
    echo 3rd
  else
    echo ${1}th
  fi
} # }}

_sf_get_values () { # {{{
  # Get variables
  touch "$_s_file"
  local orig_ifs=$IFS
  IFS="$_s_s"
  [ $_s_stdin -eq 0 ] && _s_inputs=($(cat "$_s_file")) || _s_inputs=($(cat -))
  IFS=$orig_ifs
  _s_n=${#_s_inputs[@]}
} # }}}

_sf_align_valuse () { # {{{
  local n=${1:-0}
  local v="${_s_inputs[$n]}"
  printf "$v$_s_s" > "$_s_file"
  local i=0
  for ((i=0; i<_s_n; i++));do
    if [ ! $i -eq $n ];then
      printf "${_s_inputs[$i]}$_s_s" >> "$_s_file"
    fi
  done
  _sf_get_values
} # }}}

_sf_delete () { # {{{
  local n=${1:-$((${#_s_inputs[@]}-1))}
  rm -f "$_s_file"
  local i
  for ((i=0; i<$_s_n; i++));do
    [ $i -ne $n ] && echo "${_s_inputs[$i]}$_s_s" >> "$_s_file"
  done
  _sf_get_values
} # }}}

_sf_clear () { # {{{
  # clear after selection
  clear >/dev/tty

  # Show cursor
  tput cnorm >/dev/tty 2>/dev/null || tput vs >/dev/tty 2>/dev/null

  # Restore display
  tput rmcup >/dev/tty 2>/dev/null || tput te >/dev/tty 2>/dev/null

  # Enable echo input
  [ "$_s_stdin" != "" ] && [ $_s_stdin -eq 0 ] && stty echo

} # }}}

_sf_release () { # {{{
  # Release variables
  unset _s_file
  unset _s_s
  unset _s_inputs
  unset _s_n
  unset _s_max
  unset _s_header
  unset _s_noheader
  unset _s_nonumber
  unset _s_showlast
  unset _s_lines
  unset _s_cols
  unset _s_max_show
  unset _s_stdin
  unset _s_align
  unset _s_delete

  unset _s_current_n
  unset _s_n_offset
  unset _s_cursor_r
  unset _s_g
  unset _s_n_move

  unset _s_help

  [ $_s_zsh_ksharrays -eq 1 ] && unsetopt ksharrays
  unset _s_zsh_ksharrays

} # }}}

_sf_printline () { # useage: _sf_printline is_selected n_line n_input {{{
  local show="$(echo "${_s_inputs[$3]}"|tr '\n' '\n'|sed 's/\n$//' |sed 's/%/%%/g'|sed 's/\\/\\\\/g')"
  tput cup $2 0 >/dev/tty
  if [ $1 -eq 1 ];then
    printf "\e[7m" >/dev/tty
  fi
  local n_show=$_s_cols
  local num=""
  if [ $_s_nonumber -eq 0 ];then
    n_show=$((_s_cols-5))
    num=$(printf "%3d: " $(($3+1)))
  fi
  if [ ${#show} -gt $n_show ];then
    if [ $_s_showlast -eq 0 ];then
      printf "$num${show: 0: $n_show}" >/dev/tty
    else
      printf "$num${show: $((${#show}-$n_show))}" >/dev/tty
    fi
  else
    printf "$num${show}" >/dev/tty
  fi
  if [ $1 -eq 1 ];then
    printf "\e[m" >/dev/tty
  fi
  tput cup $2 0 >/dev/tty
} # }}}

_sf_printall () { # usage: _sf_printall offset select {{{
  local offset=${1-$_s_n_offset}
  local select=${2-$_s_current_n}

  clear >/dev/tty

  # Header
  [ $_s_noheader != 1 ] && echo "$_s_header" >/dev/tty

  local i=0
  for ((i=0; i<_s_max_show; i++));do
    if [ $((i+offset)) -eq $select ];then
      _sf_printline 1 $((i+_s_ext_row)) $((i+offset))
    else
      _sf_printline 0 $((i+_s_ext_row)) $((i+offset))
    fi
  done
} # }}}

_sf_setheader () { # {{{
  if [ $_s_noheader != 1 ];then
    if [ $_s_stdin -eq 0 -a $_s_delete -eq 1 ];then
      _s_header=" $_s_n values in total
 [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n),
 ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up),
 d(delete), Enter(select), q/Esc(quit)
"
    else
      _s_header=" $_s_n values in total
 [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n),
 ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up),
 Enter(select), q/Esc(quit)
"
    fi
    _s_ext_row=$(echo "$_s_header"|wc -l)
  else
    _s_header=""
    _s_ext_row=0
  fi

  _s_max_show=$_s_n
  if [ $_s_n -gt $((_s_lines-_s_ext_row)) ];then
    _s_max_show=$((_s_lines-_s_ext_row))
  fi
} # }}}

_sf_execute () { # {{{
  local n=${1:-0}
  echo "${_s_inputs[$1]}"
} # }}}

_sf_a () { # {{{
  return 0
} # }}}
_sf_b () { # {{{
  return 0
} # }}}
_sf_c () { # {{{
  return 0
} # }}}
_sf_e () { # {{{
  return 0
} # }}}
_sf_f () { # {{{
  return 0
} # }}}
_sf_g () { # {{{
  return 0
} # }}}
_sf_h () { # {{{
  return 0
} # }}}
_sf_i () { # {{{
  return 0
} # }}}
_sf_l () { # {{{
  return 0
} # }}}
_sf_m () { # {{{
  return 0
} # }}}
_sf_n () { # {{{
  return 0
} # }}}
_sf_o () { # {{{
  return 0
} # }}}
_sf_p () { # {{{
  return 0
} # }}}
_sf_r () { # {{{
  return 0
} # }}}
_sf_s () { # {{{
  return 0
} # }}}
_sf_t () { # {{{
  return 0
} # }}}
_sf_u () { # {{{
  return 0
} # }}}
_sf_v () { # {{{
  return 0
} # }}}
_sf_w () { # {{{
  return 0
} # }}}
_sf_x () { # {{{
  return 0
} # }}}
_sf_y () { # {{{
  return 0
} # }}}
_sf_z () { # {{{
  return 0
} # }}}

_sf_main () { # {{{
  # Check only source or not
  if [ $# -ge 1 -a "$1" = "-n" ];then
    return 0
  fi

  # Set variables
  _s_file="${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE}"
  _s_s="${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR}"
  _s_inputs=()
  _s_n=0
  _s_max=${SENTAKU_MAX:-$SENTAKU_MAX}
  _s_header=""
  _s_noheader=${SENTAKU_NOHEADER:-$_SENTAKU_NOHEADER}
  _s_nonumber=${SENTAKU_NONUMBER:-$_SENTAKU_NONUMBER}
  _s_showlast=${SENTAKU_SHOWLAST:-$_SENTAKU_SHOWLAST}
  _s_lines=0
  _s_cols=0
  _s_max_show=0
  _s_stdin=0
  _s_align=0
  _s_delete=0

  _s_current_n=0
  _s_n_offset=0
  _s_cursor_r=0
  _s_g=0
  _s_n_move=0

  _s_zsh_ksharrays=0

  # Help
  _s_help=${_s_help:-"
Usage: sentaku [-nh] [-f <file>] [-s <sep>]

Arguments:
   -f <file>  Set iput file (default: ${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE})
   -s <sep>   Set separtor (default: ${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR})
   -H         Header is shown at selection mode
   -N         No nubmers are shown
   -l         Show last words instead of starting words for longer lines
   -a         Align input list (set selected one to the first)
   -d         Enable Delete in selection mode
   -n         Don't run functions, to just source this file
   -h         Print this HELP and exit
"}

  # Fix array for zsh
  if [ "$ZSH_NAME" = "zsh" ];then
    if ! setopt|grep -q ksharrays;then
      _s_zsh_ksharrays=1
      setopt ksharrays
    fi
  fi

  # Check std input
  [ ! -t 0 ] && _s_stdin=1

  # Set trap
  trap "_sf_clear;_sf_release;return 1" 1 2 3 15

  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-f" )
        _s_file=$2
        if [ "$_s_file" = "" ];then
          echo "ERROR: empty input was given with -i" >/dev/tty
          return 1
        fi
        shift 2
        ;;
      "-s" ) _s_s=$2;shift 2;;
      "-H" ) _s_noheader=0;shift;;
      "-N" ) _s_nonumber=1;shift;;
      "-l" ) _s_showlast=1;shift;;
      "-a" ) _s_align=1;shift;;
      "-d" ) _s_delete=1;shift;;
      "-h" ) echo "$_s_help" >/dev/tty;return 0;;
      * ) echo "$_s_help" >/dev/tty;return 1;;
    esac
  done


  # Get values
  _sf_get_values

  # Check a number of clipboards
  if [ $_s_n -eq 0 ];then
    if [ $_s_stdin -eq 0 ];then
      printf "No value in $_s_file\n\n" >/dev/tty
    else
      printf "No value in stdin\n\n" >/dev/tty
    fi
    sleep 1
    return
  fi

  # Hide cursor
  tput civis >/dev/tty 2>/dev/null || tput vi >/dev/tty 2>/dev/null

  # Save current display
  tput smcup >/dev/tty 2>/dev/null || tput ti >/dev/tty 2>/dev/null

  # Hide any input
  [ $_s_stdin -eq 0 ] && stty -echo

  # First view
  _s_lines=$(tput lines)
  _s_cols=$(tput cols)
  _sf_setheader
  _sf_printall

  # Select value
  _s_current_n=0
  _s_n_offset=0
  _s_cursor_r=$_s_ext_row
  _s_g=0
  _s_n_move=0
  tput cup $cursor_r 0 >/dev/tty

  local c
  while : ;do
    if [ "$ZSH_NAME" = "zsh" ];then
      read -s -k 1 c </dev/tty
    else
      read -s -n 1 c </dev/tty
    fi
    case $c in
      j|$'\x04'|$'\x06' ) # j/^D/^F
        if [ $c = $'\x04' ];then
          _s_n_move=$((_s_max_show/2))
        elif [ $c = $'\x06' ];then
          _s_n_move=$((_s_max_show))
        elif [ $_s_n_move -eq 0 ];then
          _s_n_move=1
        fi
        local all=0
        _sf_printline 0 $_s_cursor_r $_s_current_n
        local i=0
        for ((i=0; i<_s_n_move; i++));do
          if [ $_s_current_n -eq $((_s_n-1)) ];then
            :
          elif [ $_s_cursor_r -eq $((lines-1)) ];then
            ((_s_n_offset++));((_s_current_n++))
            all=1
          else
            ((_s_cursor_r++));((_s_current_n++))
          fi
        done
        if [ $all -eq 1 ];then
          _sf_printall
        else
          _sf_printline 1 $_s_cursor_r $_s_current_n
        fi
        _s_g=0
        _s_n_move=0
        continue
        ;;
      k|$'\x15'|$'\x02' ) # k/^U/^B
        if [ $c = $'\x15' ];then
          _s_n_move=$((_s_max_show/2))
        elif [ $c = $'\x02' ];then
          _s_n_move=$((_s_max_show))
        elif [ $_s_n_move -eq 0 ];then
          _s_n_move=1
        fi
        local all=0
        _sf_printline 0 $_s_cursor_r $_s_current_n
        local i=0
        for ((i=0; i<_s_n_move; i++));do
          if [ $_s_cursor_r -ne $_s_ext_row ];then
            ((_s_cursor_r--));((_s_current_n--))
          elif [ $_s_n_offset -gt 0 ];then
            ((_s_n_offset--));((_s_current_n--))
            all=1
          else
            :
          fi
        done
        if [ $all -eq 1 ];then
          _sf_printall
        else
          _sf_printline 1 $_s_cursor_r $_s_current_n
        fi
        _s_g=0
        _s_n_move=0
        continue
        ;;
      g )
        if [ $_s_g -eq 0 ];then
          _s_g=1
          continue
        fi

        if [ $_s_n_move -eq 0 ];then
          _s_current_n=0
          _s_n_offset=0
          _s_cursor_r="$_s_ext_row"
        elif [ $_s_n_move -gt $_s_n ];then
          :
        elif [ $_s_n_move -le $_s_n_offset ];then
          _s_current_n=$((_s_n_move-1))
          _s_n_offset=$_s_current_n
          _s_cursor_r=$_s_ext_row
        elif [ $((_s_n_move)) -gt $((_s_n_offset+_s_max_show)) ];then
          _s_current_n=$((_s_n_move-1))
          _s_n_offset=$((n-_s_max_show+1))
          _s_cursor_r=$((lines-1))
        else
          _s_current_n=$((_s_n_move-1))
          _s_cursor_r=$((_s_ext_row+_s_current_n-_s_n_offset))
        fi
        _sf_printall
        _s_n_move=0
        _s_g=0
        continue
        ;;
      "G" )
        if [ $_s_n_move -eq 0 ];then
          _s_current_n=$((_s_n-1))
          if [ $_s_current_n -ge $_s_max_show ];then
            _s_n_offset=$((_s_n-_s_max_show))
            _s_cursor_r=$((lines-1))
          else
            _s_n_offset=0
            _s_cursor_r=$((_s_ext_row+_s_current_n))
          fi
        elif [ $_s_n_move -gt $_s_n ];then
          :
        elif [ $_s_n_move -le $_s_n_offset ];then
          _s_current_n=$((_s_n_move-1))
          _s_n_offset=$_s_current_n
          _s_cursor_r=$_s_ext_row
        elif [ $_s_n_move -gt $((_s_n_offset+_s_max_show)) ];then
          _s_current_n=$((_s_n_move-1))
          _s_n_offset=$((_s_current_n-_s_max_show+1))
          _s_cursor_r=$((lines-1))
        else
          _s_current_n=$((_s_n_move-1))
          _s_cursor_r=$((_s_ext_row+_s_current_n-_s_n_offset))
        fi
        _sf_printall
        _s_n_move=0
        _s_g=0
        continue
        ;;
      d )
        [ $_s_stdin -eq 1 -o $_s_delete -eq 0 ] && continue
        _sf_delete $_s_current_n
        # Check a number of clipboards
        if [ $_s_n -eq 0 ];then
          clear >/dev/tty
          printf "No clipboards in $f_use\n\n" >/dev/tty
          sleep 1
          _s_current_n=-1
          break
        fi
        if [ $_s_current_n -eq $_s_n ];then
          if [ $_s_n_offset -gt 0 ];then
            ((_s_n_offset--));((_s_current_n--))
          else
            ((_s_cursor_r--));((_s_current_n--))
          fi
        fi
        _sf_setheader
        _sf_printall
        ;;
      s )
        clear >/dev/tty
        echo "$(_sf_nth $((_s_current_n+1))) value:" >/dev/tty
        echo >/dev/tty
        echo "${_s_inputs[$_s_current_n]}" >/dev/tty
        if [ "$ZSH_NAME" = "zsh" ];then
          read -s -k 1 c </dev/tty
        else
          read -s -n 1 c </dev/tty
        fi
        _sf_printall
        continue
        ;;
      q|$'\01b' ) _s_current_n=-1; break;;
      ""|$'\n' ) break;;
      [0-9])
        [ $_s_n_move -gt 0 ] && _s_n_move="$_s_n_move""$c" || _s_n_move=$c
        continue
        ;;
      a ) _sf_a;;
      b ) _sf_b;;
      c ) _sf_c;;
      #d ) _sf_d;;
      e ) _sf_e;;
      f ) _sf_f;;
      #g ) _sf_g;;
      h ) _sf_h;;
      i ) _sf_i;;
      #j ) _sf_j;;
      #k ) _sf_k;;
      l ) _sf_l;;
      m ) _sf_m;;
      n ) _sf_n;;
      o ) _sf_o;;
      p ) _sf_p;;
      #q ) _sf_q;;
      r ) _sf_r;;
      #s ) _sf_s;;
      t ) _sf_t;;
      u ) _sf_u;;
      v ) _sf_v;;
      w ) _sf_w;;
      x ) _sf_x;;
      y ) _sf_y;;
      z ) _sf_z;;
      * ) continue;;
    esac
  done

  # Clear (Show cursor, Restore display, Enable echo input)
  _sf_clear

  if [ $_s_current_n -ge 0 ];then
    # Execution for selected value
    _sf_execute $_s_current_n

    # Align values
    [ $_s_align -eq 1 -a $_s_stdin -eq 0 ] && _sf_align_valuse $_s_current_n
  fi

  # Release variables
  _sf_release
} # }}}

_sf_push () { # {{{
  # Set variables
  _s_file="${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE}"
  _s_s="${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR}"
  _s_inputs=()
  _s_n=0
  _s_max=${SENTAKU_MAX:-$SENTAKU_MAX}
  _s_header=""
  _s_noheader=${SENTAKU_NOHEADER:-$_SENTAKU_NOHEADER}
  _s_lines=0
  _s_cols=0
  _s_max_show=0
  _s_stdin=0
  _s_zsh_ksharrays=0

  # Fix array for zsh
  if [ "$ZSH_NAME" = "zsh" ];then
    if setopt|grep -q ksharrays;then
      _s_zsh_ksharrays=1
      setopt ksharrays
    fi
  fi

  # Check std input
  [ ! -t 0 ] && _s_stdin=1

  # Set trap
  trap "_sf_clear;_sf_release" 1 2 3 15

  # Set input
  local input="$*"
  if [ $_s_stdin -eq 1 ];then
    input=$(cat -)
  fi

  # Ignore blank
  [ "$input" = "" ] && return

  # Renew variables
  _sf_get_values
  local i=0
  local j=1
  printf "$input$_s_s" > "$_s_file"
  while [ $i -lt $_s_n ] && [ $j -lt $_s_max ] ;do
    local iuse=$i
    ((i++))

    # Remove duplications
    [ "$input" = "${_s_inputs[$iuse]}" ] && continue
    printf "${_s_inputs[$iuse]}$_s_s" >> "$_s_file"
    ((j++))
  done

  # Release variables
  _sf_release
} # }}}

# Execute if stdin is available
if [ ! -t 0 ];then
  _sf_main $*
fi
