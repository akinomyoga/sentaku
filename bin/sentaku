#!/usr/bin/env bash

# Default variables
_SENTAKU_INPUT_FILE="$HOME/.sentaku_input"
_SENTAKU_SEPARATOR=$'\n'
_SENTAKU_MAX=20
_SENTAKU_NOHEADER=0
_SENTAKU_NONUMBER=0
_SENTAKU_SHOWLAST=0

_sf_nth () { # {{{
  if [ $1 -eq 1 ];then
    echo 1st
  elif [ $1 -eq 2 ];then
    echo 2nd
  elif [ $1 -eq 3 ];then
    echo 3rd
  else
    echo ${1}th
  fi
} # }}}

_sf_read () { # can be used as dummy wait, too {{{
  local c
  if [ "$ZSH_NAME" = "zsh" ];then
    read -s -k 1 c </dev/tty
  else
    read -s -n 1 c </dev/tty
  fi
  echo "$c"
} # }}}

_sf_check_args () { # {{{
  # Get arguments
  while [ $# -gt 0 ];do
    case $1 in
      "-f" )
        _s_file=$2
        if [ "$_s_file" = "" ];then
          echo "ERROR: empty input was given with -i" >/dev/tty
          local dummy=$(_sf_read)
          return 1
        fi
        shift 2
        ;;
      "-s" ) _s_s=$2;shift 2;;
      "-H" ) _s_noheader=1;shift;;
      "-N" ) _s_nonumber=1;shift;;
      "-l" ) _s_showlast=1;shift;;
      "-a" ) _s_align=1;shift;;
      "-d" ) _s_delete=1;shift;;
      "-p" )
        shift
        _sf_push $*
        return 0
        ;;
      "-h" )
        echo "$_s_help" >/dev/tty
        local dummy=$(_sf_read)
        return 0
        ;;
      * )
        echo "$_s_help" >/dev/tty
        local dummy=$(_sf_read)
        return 1
        ;;
    esac
  done
  return 10
} # }}}

_sf_get_values () { # _sf_get_values [<is_stdin>] [<is_check>] {{{
  local stdin=$_s_stdin
  local check=1
  if [ $# -gt 0 ];then
    stdin=$1
  fi
  if [ $# -gt 1 ];then
    check=$2
  fi
  # Get values
  touch "$_s_file"
  local orig_ifs=$IFS
  IFS="$_s_s"
  [ $stdin -eq 0 ] && _s_inputs=($(cat "$_s_file")) || _s_inputs=($(cat -))
  IFS=$orig_ifs
  _s_n=${#_s_inputs[@]}

  if [ $check -eq 1 -a $_s_n -eq 0 ];then
    if [ $stdin -eq 0 ];then
      printf "No value in $_s_file\n\n" >/dev/tty
    else
      printf "No value in stdin\n\n" >/dev/tty
    fi
    local dummy=$(_sf_read)
    return 1
  fi
  return 0
} # }}}

_sf_align_values () { # {{{
  local n=${1:-0}
  local is_get=${2:-1}
  local v="${_s_inputs[$n]}"
  printf "$v$_s_s" > "$_s_file"
  local i=0
  for ((i=0; i<_s_n && i<_s_max; i++));do
    if [ ! $i -eq $n -a "${_s_inputs[$i]}" != "$v" ];then
      printf "${_s_inputs[$i]}$_s_s" >> "$_s_file"
    fi
  done
  if [ $is_get -eq 1 ];then
    _sf_get_values
  fi
} # }}}

_sf_delete () { # {{{
  local n=${1:-$((${#_s_inputs[@]}-1))}
  rm -f "$_s_file"
  local i
  for ((i=0; i<$_s_n; i++));do
    [ $i -ne $n ] && echo "${_s_inputs[$i]}$_s_s" >> "$_s_file"
  done
  _sf_get_values
} # }}}

_sf_clear () { # {{{
  # clear after selection
  clear >/dev/tty

  # Restore display
  tput rmcup >/dev/tty 2>/dev/null || tput te >/dev/tty 2>/dev/null

} # }}}

_sf_initialize () { # {{{
  # Set variables
  _s_file="${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE}"
  _s_s="${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR}"
  _s_inputs=()
  _s_n=0
  _s_max=${SENTAKU_MAX:-$_SENTAKU_MAX}
  _s_header=""
  _s_noheader=${SENTAKU_NOHEADER:-$_SENTAKU_NOHEADER}
  _s_nonumber=${SENTAKU_NONUMBER:-$_SENTAKU_NONUMBER}
  _s_showlast=${SENTAKU_SHOWLAST:-$_SENTAKU_SHOWLAST}
  _s_lines=0
  _s_cols=0
  _s_max_show=0
  _s_stdin=0
  _s_align=0
  _s_delete=0

  _s_current_n=0
  _s_n_offset=0
  _s_cursor_r=0
  _s_g=0
  _s_n_move=0
  _s_break=0

  _s_zsh_ksharrays=0

  # Help
  _s_help=${_s_help:-"
Usage: sentaku [-HNladnh] [-f <file>] [-s <sep>]

Arguments:
   -f <file>  Set iput file (default: ${SENTAKU_INPUT_FILE:-$_SENTAKU_INPUT_FILE})
   -s <sep>   Set separtor (default: ${SENTAKU_SEPARATOR:-$_SENTAKU_SEPARATOR})
   -H         Header is shown at selection mode
   -N         No nubmers are shown
   -l         Show last words instead of starting words for longer lines
   -a         Align input list (set selected one to the first)
   -d         Enable Delete in selection mode
   -p         Push words to the file
   -n         Don't run functions, to just source this file
   -h         Print this HELP and exit
"}

  # Fix array for zsh
  if [ "$ZSH_NAME" = "zsh" ];then
    if ! setopt|grep -q ksharrays;then
      _s_zsh_ksharrays=1
      setopt ksharrays
    fi
  fi

  # Check std input
  [ ! -t 0 ] && _s_stdin=1

  # User initialization
  _sf_initialize_user
} # }}}

_sf_initialize_user () { # {{{
  :
} # }}}

_sf_finalize () { # {{{
  # Show cursor
  tput cnorm >/dev/tty 2>/dev/null || tput vs >/dev/tty 2>/dev/null

  # Enable echo input
  [ "x$_s_stdin" != "x" ] && [ $_s_stdin -eq 0 ] && stty echo

  # Release variables
  unset _s_file
  unset _s_s
  unset _s_inputs
  unset _s_n
  unset _s_max
  unset _s_header
  unset _s_noheader
  unset _s_nonumber
  unset _s_showlast
  unset _s_lines
  unset _s_cols
  unset _s_max_show
  unset _s_stdin
  unset _s_align
  unset _s_delete

  unset _s_current_n
  unset _s_n_offset
  unset _s_cursor_r
  unset _s_g
  unset _s_n_move
  unset _s_break

  unset _s_help

  [ "x$_s_zsh_ksharrays" != "x" ] && [ $_s_zsh_ksharrays -eq 1 ] && unsetopt ksharrays
  unset _s_zsh_ksharrays

  _sf_finalize_user
} # }}}

_sf_finalize_user () { # {{{
  :
} # }}}

_sf_printline () { # useage: _sf_printline is_selected n_line n_input {{{
  local show="$(echo "${_s_inputs[$3]}"|tr '\n' '\n'|sed 's/\n$//' |sed 's/%/%%/g'|sed 's/\\/\\\\/g')"
  tput cup $2 0 >/dev/tty
  if [ $1 -eq 1 ];then
    printf "\e[7m" >/dev/tty
  fi
  local n_show=$_s_cols
  local num=""
  if [ $_s_nonumber -eq 0 ];then
    n_show=$((_s_cols-5))
    num=$(printf "%3d: " $3)
  fi
  if [ ${#show} -gt $n_show ];then
    if [ $_s_showlast -eq 0 ];then
      if [ "$ZSH_NAME" = "zsh" ];then # need for zsh version < 5
        printf "$num${show[0,$((n_show-1))]}" >/dev/tty
      else
        printf "$num${show: 0: $n_show}" >/dev/tty
      fi
    else
      if [ "$ZSH_NAME" = "zsh" ];then # need for zsh version < 5
        printf "$num${show[$((${#show}-$n_show)),-1]}" >/dev/tty
      else
        printf "$num${show: $((${#show}-$n_show))}" >/dev/tty
      fi
    fi
  else
    printf "$num${show}" >/dev/tty
  fi
  if [ $1 -eq 1 ];then
    printf "\e[m" >/dev/tty
  fi
  tput cup $2 0 >/dev/tty
} # }}}

_sf_printall () { # usage: _sf_printall offset select {{{
  _sf_setview

  local offset=${1-$_s_n_offset}
  local select=${2-$_s_current_n}

  clear >/dev/tty

  # Header
  [ $_s_noheader != 1 ] && echo "$_s_header" >/dev/tty

  local i=0
  for ((i=0; i<_s_max_show; i++));do
    if [ $((i+offset)) -eq $select ];then
      _sf_printline 1 $((i+_s_ext_row)) $((i+offset))
    else
      _sf_printline 0 $((i+_s_ext_row)) $((i+offset))
    fi
  done
} # }}}

_sf_setheader () { # {{{
  _s_header=""
  if [ $_s_noheader != 1 ];then
    if [ $_s_stdin -eq 0 -a $_s_delete -eq 1 ];then
      if [ $_s_cols -ge 66 ];then
        _s_header=" $_s_n values in total
 [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n),
 ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up),
 d(delete), Enter(select), q/Esc(quit)
"
      elif [ $_s_cols -ge 40 ];then
        _s_header=" $_s_n values in total
 vim-like updown, e.g)j:up, k:down, gg/G
 d(delete), Enter(select), q/Esc(quit)
"
      fi

    else
      if [ $_s_cols -ge 66 ];then
        _s_header=" $_s_n values in total
 [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n),
 ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up),
 Enter(select), q/Esc(quit)
"
      else
        _s_header=" $_s_n values in total
 vim-like updown, e.g)j:up, k:down, gg/G
 Enter(select), q/Esc(quit)
"
      fi
    fi
  fi
}  # }}}

_sf_setview () { # {{{
  _sf_setheader
  if [ "$_s_header" = "" ];then
    _s_ext_row=0
  else
    _s_ext_row=$(echo "$_s_header"|wc -l)
  fi

  _s_max_show=$_s_n
  if [ $_s_n -gt $((_s_lines-_s_ext_row)) ];then
    _s_max_show=$((_s_lines-_s_ext_row))
  fi
} # }}}

_sf_execute () { # {{{
  local n=${1:-0}
  echo "${_s_inputs[$1]}"
} # }}}

_sf_move_up () { # {{{
  local all=0
  _sf_printline 0 $_s_cursor_r $_s_current_n
  local i=0
  for ((i=0; i<_s_n_move; i++));do
    if [ $_s_current_n -eq $((_s_n-1)) ];then
      :
    elif [ $_s_cursor_r -eq $((_s_lines-1)) ];then
      ((_s_n_offset++));((_s_current_n++))
      all=1
    else
      ((_s_cursor_r++));((_s_current_n++))
    fi
  done
  if [ $all -eq 1 ];then
    _sf_printall
  else
    _sf_printline 1 $_s_cursor_r $_s_current_n
  fi
  _s_g=0
  _s_n_move=0
} # }}}

_sf_move_down () { # {{{
  local all=0
  _sf_printline 0 $_s_cursor_r $_s_current_n
  local i=0
  for ((i=0; i<_s_n_move; i++));do
    if [ $_s_cursor_r -ne $_s_ext_row ];then
      ((_s_cursor_r--));((_s_current_n--))
    elif [ $_s_n_offset -gt 0 ];then
      ((_s_n_offset--));((_s_current_n--))
      all=1
    else
      :
    fi
  done
  if [ $all -eq 1 ];then
    _sf_printall
  else
    _sf_printline 1 $_s_cursor_r $_s_current_n
  fi
  _s_g=0
  _s_n_move=0
} # }}}

_sf_quit () { # {{{
  _s_current_n=-1
  _s_break=1
} # }}}

_sf_select () { # {{{
  _s_break=1
} # }}}

_sf_a () { # {{{
  :
} # }}}
_sf_b () { # {{{
  :
} # }}}
_sf_c () { # {{{
  :
} # }}}
_sf_d () { # {{{
  [ $_s_stdin -eq 1 -o $_s_delete -eq 0 ] && continue
  _sf_delete $_s_current_n
  local ret=$?
  if [ $ret -ne 0 ];then
    _s_current_n=-1
    _s_break=1
    return $ret
  fi
  if [ $_s_current_n -eq $_s_n ];then
    if [ $_s_n_offset -gt 0 ];then
      ((_s_n_offset--));((_s_current_n--))
    else
      ((_s_cursor_r--));((_s_current_n--))
    fi
  fi
  _sf_printall
} # }}}
_sf_e () { # {{{
  :
} # }}}
_sf_f () { # {{{
  :
} # }}}
_sf_g () { # {{{
  if [ $_s_g -eq 0 ];then
    _s_g=1
    return
  fi
  if [ $_s_n_move -eq 0 ];then
    _s_current_n=0
    _s_n_offset=0
    _s_cursor_r="$_s_ext_row"
  elif [ $_s_n_move -gt $_s_n ];then
    :
  elif [ $_s_n_move -le $_s_n_offset ];then
    _s_current_n=$((_s_n_move))
    _s_n_offset=$_s_current_n
    _s_cursor_r=$_s_ext_row
  elif [ $((_s_n_move)) -gt $((_s_n_offset+_s_max_show)) ];then
    _s_current_n=$((_s_n_move))
    _s_n_offset=$((n-_s_max_show+1))
    _s_cursor_r=$((_s_lines-1))
  else
    _s_current_n=$((_s_n_move))
    _s_cursor_r=$((_s_ext_row+_s_current_n-_s_n_offset))
  fi
  _sf_printall
  _s_n_move=0
  _s_g=0
} # }}}
_sf_h () { # {{{
  :
} # }}}
_sf_i () { # {{{
  :
} # }}}
_sf_j () { # {{{
  [ $_s_n_move -eq 0 ] && _s_n_move=1
  _sf_move_up
} # }}}
_sf_k () { # {{{
  [ $_s_n_move -eq 0 ] && _s_n_move=1
  _sf_move_down
} # }}}
_sf_l () { # {{{
  :
} # }}}
_sf_m () { # {{{
  :
} # }}}
_sf_n () { # {{{
  :
} # }}}
_sf_o () { # {{{
  :
} # }}}
_sf_p () { # {{{
  :
} # }}}
_sf_q () { # {{{
  _sf_quit
} # }}}
_sf_r () { # {{{
  :
} # }}}
_sf_s () { # {{{
  clear >/dev/tty
  echo "$(_sf_nth $((_s_current_n))) value:" >/dev/tty
  echo >/dev/tty
  echo "${_s_inputs[$_s_current_n]}" >/dev/tty
  local dummy=$(_sf_read)
  _sf_printall
} # }}}
_sf_t () { # {{{
  :
} # }}}
_sf_u () { # {{{
  :
} # }}}
_sf_v () { # {{{
  :
} # }}}
_sf_w () { # {{{
  :
} # }}}
_sf_x () { # {{{
  :
} # }}}
_sf_y () { # {{{
  :
} # }}}
_sf_z () { # {{{
  :
} # }}}

_sf_A () { # {{{
  :
} # }}}
_sf_B () { # {{{
  :
} # }}}
_sf_C () { # {{{
  :
} # }}}
_sf_D () { # {{{
  :
} # }}}
_sf_E () { # {{{
  :
} # }}}
_sf_F () { # {{{
  :
} # }}}
_sf_G () { # {{{
  if [ $_s_n_move -eq 0 ];then
    _s_current_n=$((_s_n-1))
    if [ $_s_current_n -ge $_s_max_show ];then
      _s_n_offset=$((_s_n-_s_max_show))
      _s_cursor_r=$((_s_lines-1))
    else
      _s_n_offset=0
      _s_cursor_r=$((_s_ext_row+_s_current_n))
    fi
  elif [ $_s_n_move -gt $_s_n ];then
    :
  elif [ $_s_n_move -le $_s_n_offset ];then
    _s_current_n=$((_s_n_move))
    _s_n_offset=$_s_current_n
    _s_cursor_r=$_s_ext_row
  elif [ $_s_n_move -gt $((_s_n_offset+_s_max_show)) ];then
    _s_current_n=$((_s_n_move))
    _s_n_offset=$((_s_current_n-_s_max_show+1))
    _s_cursor_r=$((_s_lines-1))
  else
    _s_current_n=$((_s_n_move))
    _s_cursor_r=$((_s_ext_row+_s_current_n-_s_n_offset))
  fi
  _sf_printall
  _s_n_move=0
  _s_g=0
} # }}}
_sf_H () { # {{{
  :
} # }}}
_sf_I () { # {{{
  :
} # }}}
_sf_J () { # {{{
  :
} # }}}
_sf_K () { # {{{
  :
} # }}}
_sf_L () { # {{{
  :
} # }}}
_sf_M () { # {{{
  :
} # }}}
_sf_N () { # {{{
  :
} # }}}
_sf_O () { # {{{
  :
} # }}}
_sf_P () { # {{{
  :
} # }}}
_sf_Q () { # {{{
  :
} # }}}
_sf_R () { # {{{
  :
} # }}}
_sf_S () { # {{{
  :
} # }}}
_sf_T () { # {{{
  :
} # }}}
_sf_U () { # {{{
  :
} # }}}
_sf_V () { # {{{
  :
} # }}}
_sf_W () { # {{{
  :
} # }}}
_sf_X () { # {{{
  :
} # }}}
_sf_Y () { # {{{
  :
} # }}}
_sf_Z () { # {{{
  :
} # }}}

_sf_push () { # {{{
  # Set trap
  trap "_sf_clear;return 1" 1 2 3 15
  trap "_sf_finalize" 0

  # Initializatoin
  _sf_initialize

  # Set input
  local input="$*"
  shift $#
  if [ $_s_stdin -eq 1 ];then
    input=$(cat -)
  fi

  # Ignore blank
  [ "$input" = "" ] && return

  # Renew values
  _sf_get_values 0 0
  _s_inputs=("$input" "${_s_inputs[@]}")
  _s_n=${#_s_inputs[@]}
  _sf_align_values 0 0

  # Finalization
  _sf_finalize
} # }}}

_sf_main () { # {{{
  # Check only source or not
  if [ $# -ge 1 -a "$1" = "-n" ];then
    return 0
  fi

  # Set trap
  trap "_sf_clear;return 1" 1 2 3 15
  trap "_sf_finalize" 0


  # Initializatoin
  _sf_initialize

  # Get arguments
  _sf_check_args $*
  local ret=$?
  if [ $ret -ne 10 ];then
    return $ret
  fi

  # Get values
  _sf_get_values
  local ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi

  # Hide cursor
  tput civis >/dev/tty 2>/dev/null || tput vi >/dev/tty 2>/dev/null

  # Save current display
  tput smcup >/dev/tty 2>/dev/null || tput ti >/dev/tty 2>/dev/null

  # Hide any input
  [ $_s_stdin -eq 0 ] && stty -echo

  # First view
  _s_lines=$(tput lines)
  _s_cols=$(tput cols)
  _sf_printall

  # Select value
  _s_current_n=0
  _s_n_offset=0
  _s_cursor_r=$_s_ext_row
  _s_g=0
  _s_n_move=0
  _s_break=0
  tput cup $cursor_r 0 >/dev/tty

  while : ;do
    local c=$(_sf_read)
    case $c in
      $'\x04'|$'\x06' ) # ^D/^F
        if [ $c = $'\x04' ];then
          _s_n_move=$((_s_max_show/2))
        elif [ $c = $'\x06' ];then
          _s_n_move=$((_s_max_show))
        fi
        _sf_move_up
        ;;
      $'\x15'|$'\x02' ) # k/^U/^B
        if [ $c = $'\x15' ];then
          _s_n_move=$((_s_max_show/2))
        elif [ $c = $'\x02' ];then
          _s_n_move=$((_s_max_show))
        fi
        _sf_move_down
        ;;
      $'\x1b' ) _sf_quit;; # Esc
      ""|$'\n' ) _sf_select;; # Enter/Space
      [0-9])
        [ $_s_n_move -gt 0 ] && _s_n_move="$_s_n_move""$c" || _s_n_move=$c
        continue
        ;;
      a ) _sf_a;;
      b ) _sf_b;;
      c ) _sf_c;;
      d ) _sf_d;;
      e ) _sf_e;;
      f ) _sf_f;;
      g ) _sf_g;;
      h ) _sf_h;;
      i ) _sf_i;;
      j ) _sf_j;;
      k ) _sf_k;;
      l ) _sf_l;;
      m ) _sf_m;;
      n ) _sf_n;;
      o ) _sf_o;;
      p ) _sf_p;;
      q ) _sf_q;;
      r ) _sf_r;;
      s ) _sf_s;;
      t ) _sf_t;;
      u ) _sf_u;;
      v ) _sf_v;;
      w ) _sf_w;;
      x ) _sf_x;;
      y ) _sf_y;;
      z ) _sf_z;;
      A ) _sf_A;;
      B ) _sf_B;;
      C ) _sf_C;;
      D ) _sf_D;;
      E ) _sf_E;;
      F ) _sf_F;;
      G ) _sf_G;;
      H ) _sf_H;;
      I ) _sf_I;;
      J ) _sf_J;;
      K ) _sf_K;;
      L ) _sf_L;;
      M ) _sf_M;;
      N ) _sf_N;;
      O ) _sf_O;;
      P ) _sf_P;;
      Q ) _sf_Q;;
      R ) _sf_R;;
      S ) _sf_S;;
      T ) _sf_T;;
      U ) _sf_U;;
      V ) _sf_V;;
      W ) _sf_W;;
      X ) _sf_X;;
      Y ) _sf_Y;;
      Z ) _sf_Z;;
      * ) continue;;
    esac
    [ $_s_break -eq 1 ] && break
  done

  # Clear (Show cursor, Restore display, Enable echo input)
  _sf_clear

  if [ $_s_current_n -ge 0 ];then
    # Execution for selected value
    _sf_execute $_s_current_n

    # Align values
    [ $_s_align -eq 1 -a $_s_stdin -eq 0 ] && _sf_align_values $_s_current_n
  fi

  # Finalization
  _sf_finalize
} # }}}

# Execute if stdin is available
#if [ ! -t 0 ];then
if [ -p /dev/stdin ];then
  _sf_main $*
fi
