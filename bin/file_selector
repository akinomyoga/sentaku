#!/usr/bin/env bash

. sentaku -n

_SENTAKU_FILE_CONTENT_LINE=${_SENTAKU_FILE_CONTENT_LINE:-10}
_SENTAKU_CONTENT_SHOW_UNDER=${_SENTAKU_CONTENT_SHOW_UNDER:-0}

_s_content_show_under=$_SENTAKU_CONTENT_SHOW_UNDER

_sf_file_content () {
  if [ $_s_file_content -eq 0 ];then
    return
  fi
  local i
  local start_line=$((_s_lines+1))
  local end_line=$(($(tput lines)-1))
  local start_col=0
  local n_cols=$_s_cols

  if [ $_s_content_show_under -eq 0 ];then
    start_line=0
    start_col=$_s_cols
    n_cols=$_s_content_cols
  fi

  for i in $(seq $start_line $end_line);do
    tput cup "$i" "$start_col" >/dev/tty
    printf "%-${n_cols}s" "" >/dev/tty
  done

  if [ $_s_content_show_under -eq 1 ];then
    tput cup "$_s_lines" 0 >/dev/tty
    if [ $n_cols -ge 20 ];then
      printf "====File content===="
    else
      printf "=="
    fi
  fi

  if ! file "${_s_inputs[$_s_current_n]}"|grep -q text;then
    if [ $_s_content_show_under -eq 0 ];then
      if [ $n_cols -ge 15 ];then
        tput cup "$start_line" "$start_col" >/dev/tty
        printf "Not a text file"
      fi
    else
      if [ $n_cols -ge 16 ];then
        tput cup "$start_line" "$start_col" >/dev/tty
        printf "|Not a text file"
      fi
    fi
  else
    i=$start_line
    while read line;do
      if [ $_s_content_show_under -eq 0 ];then
        line="|$line"
      fi
      if [ "${#line}" -gt "$n_cols" ];then
        if [ "x$ZSH_VERSION" != "x" ];then
          line="${line[0,$((n_cols-1))]}"
        else
          line="${line: 0: $n_cols}"
        fi
      fi
      tput cup "$i" $start_col >/dev/tty
      printf "%s" "$line"
      ((i++))
      if [ $i -gt $end_line ];then
        break
      fi
    done < ${_s_inputs[$_s_current_n]}
    while [ $i -lt $end_line ];do
      tput cup "$i" $start_col >/dev/tty
      printf "|"
      ((i++))
    done
  fi
}

_sf_set_header () { # {{{
  if [ $_s_content_show_under -eq 1 ];then
    if [ $((_s_lines-_SENTAKU_FILE_CONTENT_LINE-10)) -ge 0 ];then
      _s_lines=$((_s_lines-_SENTAKU_FILE_CONTENT_LINE-2))
      _s_file_content=1
    else
      _s_file_content=0
    fi
  else
    _s_file_content=1
    local full_cols=$_s_cols
    _s_cols=$((full_cols/2))
    _s_content_cols=$((full_cols-_s_cols))
  fi

  _s_header="\e[43;30m$_s_n values in total\e[0m "
  if [ "$_s_noheader" = 1 ] || [ "$_s_lines" -lt 10 ];then
    return
  fi
  if [ $_s_delete -eq 1 ];then
    local delete_key="d(delete), "
  else
    local delete_key=""
  fi
  if [ $_s_keymode -eq 0 ];then
    if [ "$_s_cols" -ge 68 ];then
      _s_header="$_s_header
  [n]j(n-down), [n]k(n-up), gg(top), G(bottom), [n]gg/G, (go to n)
  ^D(Half page down), ^U(Half page up), ^F(Page down), ^B(Page Up)
  ${delete_key}/(search), Enter/Space(select), q(quit)"
    elif [ "$_s_cols" -ge 41 ];then
      _s_header="$_s_header
  vimike updown, e.g)j:down, k:up, gg/G
  ${delete_key}Enter/Space(select), q(quit)"
    fi
  else
    if [ "$_s_cols" -ge 51 ];then
      _s_header="$_s_header
  C-n(down), C-j(up), C-v(Page down), M-v(Page up)
  ${delete_key}Enter(select), C-x(quit)
  Other normal keys start an incremental search"
    fi
  fi
}  # }}}

_sf_printline () { # useage: _sf_printline is_selected n_line n_input {{{
  if [ $# -lt 3 ];then
    _sf_echo "_sf_printline needs 3 arguments (is_selected, n_line, n_input), exit\n"
    _sf_quit 1
    return
  fi
  local is_selected=$1
  local n_line=$2
  local n_input=$3

  local color=""
  if [ ${_s_v_selected[$n_input]} -eq 1 ];then
    color="[36m"
  fi
  if [ "$is_selected" -eq 1 ];then
    if [ "$_s_line_highlight" -eq 1 ];then
      color="${color}[7m"
    else
      color="${color}[4m"
    fi
  fi

  # Change line breaks to \n (to be shown), remove the last line break, replace tab to space
  _s_show="$(echo "${_s_inputs[$n_input]}"|awk -F"\n" -v ORS="\\\\\\\\n" '{print}' |sed 's|\\\\n$||'|sed "s/\[m/[m$color/g"|sed $'s/\t/ /g')"

  tput cup "$n_line" 0 >/dev/tty
  local n_show=$_s_cols
  local num=""
  if [ $_s_nonumber -eq 0 ];then
    local nmax=$((_s_n-1))
    local num_width=${#nmax}
    n_show=$((_s_cols-num_width-2))
    num=$(printf "%${num_width}d: " "$n_input")
  fi
  _sf_show "$is_selected" "$n_show"
  if [ "$_s_col_n_only" -eq 1 ];then
    printf "${color}${num}[m${_s_show}" >/dev/tty
  else
    printf "${color}${num}${_s_show}[m" >/dev/tty
  fi
  if [ "$is_selected" -eq 1 ];then
    _sf_file_content
  fi
  tput cup "$n_line" 0 >/dev/tty
} # }}}

_sf_s () {
  output="$(_sf_nth $((_s_current_n))) value: ${_s_inputs[$_s_current_n]}
===============
"
  if [ -f ${_s_inputs[$_s_current_n]} ];then
    output="$output$(head -n $(($(tput lines)-2)) ${_s_inputs[$_s_current_n]})"
  else
    output="$output${_s_inputs[$_s_current_n]} is not a file\n"
  fi
  _sf_echo "$output"
}

if echo -- "$1"|grep -q -- "--under";then
  _s_content_show_under=1
  shift
fi
if echo -- "$1"|grep -q -- "--right";then
  _s_content_show_under=0
  shift
fi
if [ -p /dev/stdin ];then
  echo $(cat -) | _sf_main "$@"
else
  _sf_main "$@"
fi
